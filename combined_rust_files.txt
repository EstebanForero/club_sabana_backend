--- bcrypt_hasher/src/lib.rs ---
use bcrypt::{hash, verify, DEFAULT_COST};
use use_cases::user_service::err::Error::*;
use use_cases::user_service::hasher_trait::PasswordHasher;

pub struct BcryptHasher;

impl PasswordHasher for BcryptHasher {
    fn hash(&self, content: &str) -> use_cases::user_service::err::Result<String> {
        let hash_str = hash(content, DEFAULT_COST).map_err(|err| ErrorHashing(format!("{err}")))?;

        Ok(hash_str)
    }

    fn verify(&self, original: &str, hashed: &str) -> use_cases::user_service::err::Result<bool> {
        let is_valid = verify(original, hashed).map_err(|err| ErrorHashing(format!("{err}")))?;

        Ok(is_valid)
    }
}
--- entities/src/category.rs ---
use std::cmp::Ordering;

use enum2str::EnumStr;
use partial_struct::Partial;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Partial)]
#[partial(
    "CategoryCreation",
    derive(Debug, Serialize, Deserialize, Partial),
    omit(id_category)
)]
pub struct Category {
    pub id_category: Uuid,
    pub name: String,
    pub min_age: i32,
    pub max_age: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Level {
    pub level_name: LevelName,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CategoryRequirement {
    pub id_category_requirement: Uuid,
    pub id_category: Uuid,
    pub requirement_description: String,
    pub required_level: LevelName,
}

#[derive(Debug, Serialize, Deserialize, EnumStr, PartialEq)]
pub enum LevelName {
    BEGGINER,
    AMATEUR,
    PROFESSIONAL,
}

impl PartialOrd for LevelName {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        let ordering = match self {
            LevelName::BEGGINER => match other {
                LevelName::BEGGINER => Ordering::Equal,
                LevelName::AMATEUR => Ordering::Greater,
                LevelName::PROFESSIONAL => Ordering::Greater,
            },
            LevelName::AMATEUR => match other {
                LevelName::BEGGINER => Ordering::Less,
                LevelName::AMATEUR => Ordering::Equal,
                LevelName::PROFESSIONAL => Ordering::Greater,
            },
            LevelName::PROFESSIONAL => todo!(),
        };

        Some(ordering)
    }
}
--- entities/src/date_serde.rs ---
use chrono::NaiveDate;
use serde::{de, Deserialize, Deserializer, Serializer};

pub fn serialize<S>(date: &NaiveDate, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&date.format("%Y-%m-%d").to_string())
}

pub fn deserialize<'de, D>(deserializer: D) -> Result<NaiveDate, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    NaiveDate::parse_from_str(&s, "%Y-%m-%d").map_err(de::Error::custom)
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;
    use serde::{Deserialize, Serialize};
    use serde_json;

    #[derive(Debug, Serialize, Deserialize, PartialEq)]
    struct TestDate {
        #[serde(with = "super")]
        date: NaiveDate,
    }

    #[test]
    fn test_serialize() {
        let date = NaiveDate::from_ymd_opt(2023, 10, 15).unwrap();
        let test_date = TestDate { date };

        let serialized = serde_json::to_string(&test_date).unwrap();
        assert_eq!(serialized, r#"{"date":"2023-10-15"}"#);
    }

    #[test]
    fn test_deserialize() {
        let json_data = r#"{"date":"2023-10-15"}"#;
        let deserialized: TestDate = serde_json::from_str(json_data).unwrap();

        let expected_date = NaiveDate::from_ymd_opt(2023, 10, 15).unwrap();
        assert_eq!(deserialized.date, expected_date);
    }

    #[test]
    fn test_deserialize_invalid_format() {
        let json_data = r#"{"date":"15-10-2023"}"#;
        let result: Result<TestDate, _> = serde_json::from_str(json_data);

        assert!(result.is_err());
    }

    #[test]
    fn test_deserialize_invalid_date() {
        let json_data = r#"{"date":"2023-02-30"}"#; // February 30th doesn't exist
        let result: Result<TestDate, _> = serde_json::from_str(json_data);

        assert!(result.is_err());
    }
}
--- entities/src/datetime_serde.rs ---
use chrono::NaiveDateTime;
use serde::{de, Deserialize, Deserializer, Serializer};

pub fn serialize<S>(datetime: &NaiveDateTime, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str(&datetime.format("%Y-%m-%d %H:%M:%S").to_string())
}

/// Deserializes a string "YYYY-MM-DD HH:MM:SS" into a NaiveDateTime
pub fn deserialize<'de, D>(deserializer: D) -> Result<NaiveDateTime, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    NaiveDateTime::parse_from_str(&s, "%Y-%m-%d %H:%M:%S").map_err(de::Error::custom)
}

#[cfg(test)]
mod tests {
    use chrono::{DateTime, NaiveDateTime};
    use serde::{Deserialize, Serialize};
    use serde_json;

    #[derive(Debug, Serialize, Deserialize, PartialEq)]
    struct TestDateTime {
        #[serde(with = "super")]
        datetime: NaiveDateTime,
    }

    #[test]
    fn test_serialize() {
        let datetime = DateTime::from_timestamp(1672531199, 0).unwrap().naive_utc(); // 2023-01-01 23:59:59
        let test_datetime = TestDateTime { datetime };

        let serialized = serde_json::to_string(&test_datetime).unwrap();
        assert_eq!(serialized, r#"{"datetime":"2022-12-31 23:59:59"}"#);
    }

    #[test]
    fn test_deserialize() {
        let json_data = r#"{"datetime":"2022-12-31 23:59:59"}"#;
        let deserialized: TestDateTime = serde_json::from_str(json_data).unwrap();

        let expected_datetime = DateTime::from_timestamp(1672531199, 0).unwrap().naive_utc();
        assert_eq!(deserialized.datetime, expected_datetime);
    }

    #[test]
    fn test_deserialize_invalid_format() {
        let json_data = r#"{"datetime":"01-01-2022 23:59:59"}"#; // Wrong date format
        let result: Result<TestDateTime, _> = serde_json::from_str(json_data);

        assert!(result.is_err());
    }

    #[test]
    fn test_deserialize_invalid_datetime() {
        let json_data = r#"{"datetime":"2022-02-30 25:61:61"}"#; // Invalid date and time
        let result: Result<TestDateTime, _> = serde_json::from_str(json_data);

        assert!(result.is_err());
    }

    #[test]
    fn test_round_trip() {
        let original_datetime = DateTime::from_timestamp(1672531199, 0).unwrap().naive_utc();
        let test_datetime = TestDateTime {
            datetime: original_datetime,
        };

        // Serialize
        let serialized = serde_json::to_string(&test_datetime).unwrap();

        // Deserialize
        let deserialized: TestDateTime = serde_json::from_str(&serialized).unwrap();

        assert_eq!(test_datetime, deserialized);
    }
}
--- entities/src/lib.rs ---
pub mod category;
pub mod date_serde;
pub mod datetime_serde;
pub mod request;
pub mod tournament;
pub mod training;
pub mod tuition;
pub mod user;
--- entities/src/request.rs ---
use partial_struct::Partial;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Partial)]
#[partial(
    "RequestCreation",
    derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq),
    omit(request_id, approved, approver_id)
)]
pub struct Request {
    pub request_id: Uuid,
    pub requester_id: Uuid,
    pub requested_command: String,
    pub justification: String,
    pub approved: Option<bool>,
    pub approver_id: Option<Uuid>,
}
--- entities/src/tournament.rs ---
use super::datetime_serde;
use chrono::NaiveDateTime;
use partial_struct::Partial;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Partial)]
#[partial(
    "TournamentCreation",
    derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Partial),
    omit(id_tournament)
)]
pub struct Tournament {
    pub id_tournament: Uuid,
    pub name: String,
    pub id_category: Uuid,
    #[serde(with = "datetime_serde")]
    pub start_datetime: NaiveDateTime,
    #[serde(with = "datetime_serde")]
    pub end_datetime: NaiveDateTime,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct TournamentRegistration {
    pub id_tournament: Uuid,
    pub id_user: Uuid,
    #[serde(with = "datetime_serde")]
    pub registration_datetime: NaiveDateTime,
}

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct TournamentAttendance {
    pub id_tournament: Uuid,
    pub id_user: Uuid,
    #[serde(with = "datetime_serde")]
    pub attendance_datetime: NaiveDateTime,
    pub position: i32,
}
--- entities/src/training.rs ---
use super::datetime_serde;
use chrono::NaiveDateTime;
use partial_struct::Partial;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Partial)]
#[partial(
    "TrainingCreation",
    derive(Debug, Serialize, Deserialize),
    omit(id_training)
)]
pub struct Training {
    pub id_training: Uuid,
    pub name: String,
    pub id_category: Uuid,
    #[serde(with = "datetime_serde")]
    pub start_datetime: NaiveDateTime,
    #[serde(with = "datetime_serde")]
    pub end_datetime: NaiveDateTime,
    pub minimum_payment: f64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TrainingRegistration {
    pub id_training: Uuid,
    pub id_user: Uuid,
    #[serde(with = "datetime_serde")]
    pub registration_datetime: NaiveDateTime,
    pub attended: bool,
    #[serde(with = "datetime_serde")]
    pub attendance_datetime: NaiveDateTime,
}
--- entities/src/tuition.rs ---
use super::datetime_serde;
use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct Tuition {
    pub id_tuition: Uuid,
    pub id_user: Uuid,
    pub amount: f64,
    #[serde(with = "datetime_serde")]
    pub payment_date: NaiveDateTime,
}
--- entities/src/user.rs ---
use crate::category::LevelName;

use super::date_serde;
use super::datetime_serde;
use chrono::{NaiveDate, NaiveDateTime};
use enum2str::EnumStr;
use partial_struct::Partial;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq, Partial)]
#[partial(
    "UserInfo",
    derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq),
    omit(password)
)]
#[partial(
    "UserCreation",
    derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq),
    omit(id_user, registration_date, email_verified, user_rol)
)]
pub struct User {
    pub id_user: Uuid,
    pub first_name: String,
    pub last_name: String,
    #[serde(with = "date_serde")]
    pub birth_date: NaiveDate,
    #[serde(with = "datetime_serde")]
    pub registration_date: NaiveDateTime,
    pub email: String,
    pub email_verified: bool,
    pub phone_number: String,
    pub country_code: String,
    pub password: String,
    pub identification_number: String,
    pub identification_type: IdType,
    pub user_rol: URol,
}

#[derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq, Clone)]
pub struct UserLogInInfo {
    pub identifier: String,
    pub password: String,
}

#[derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq)]
pub struct DocInfo {
    pub identification_number: String,
    pub identification_type: IdType,
}

#[derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq, EnumStr, Clone)]
pub enum IdType {
    #[default]
    CC,
}

#[derive(Debug, Serialize, Deserialize, Default, PartialEq, Eq, EnumStr, Clone)]
pub enum URol {
    #[default]
    USER,
    ADMIN,
    TRAINER,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserRole {
    pub user_rol: URol,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct IdentificationInfo {
    pub identification_type: IdType,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserCategory {
    pub id_user: Uuid,
    pub id_category: Uuid,
    pub user_level: LevelName,
}
--- http_api/src/auth.rs ---
use axum::{
    extract::{Request, State},
    http::StatusCode,
    middleware::Next,
    response::IntoResponse,
};
use chrono::Utc;
use entities::user::URol;
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use tracing::{error, info};
use use_cases::user_service::LogInResponse;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: Uuid, // User id,
    exp: usize,
    iat: usize,
    user_rol: URol,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserInfoAuth {
    pub user_id: Uuid, // User id,
    pub user_rol: URol,
}

pub fn generate_jwt(
    log_in_response: &LogInResponse,
    token_key: &str,
) -> Result<String, jsonwebtoken::errors::Error> {
    let now = Utc::now().timestamp() as usize;

    let my_claims = Claims {
        sub: log_in_response.user_id,
        exp: now + 3600,
        iat: now,
        user_rol: log_in_response.user_rol.clone(),
    };

    let token = encode(
        &Header::default(),
        &my_claims,
        &EncodingKey::from_secret(token_key.as_ref()),
    );

    token
}

fn decode_jwt(token_key: &str, token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let my_claims = decode::<Claims>(
        token,
        &DecodingKey::from_secret(token_key.as_ref()),
        &Validation::default(),
    )?;

    Ok(my_claims.claims)
}

pub async fn auth_middleware(
    State(jwt_secret): State<String>,
    mut request: Request,
    next: Next,
) -> Result<impl IntoResponse, StatusCode> {
    let auth_header = request
        .headers()
        .get("Authorization")
        .and_then(|h| h.to_str().ok());

    let jwt_token_string = match auth_header {
        Some(header_value) if header_value.starts_with("Bearer ") => {
            &header_value[7..] // Remove "Bearer " prefix
        }
        _ => return Err(StatusCode::UNAUTHORIZED),
    };

    let claims = decode_jwt(&jwt_secret, jwt_token_string).map_err(|err| {
        error!("Error in token verification: {err}");
        StatusCode::UNAUTHORIZED
    })?;

    request.extensions_mut().insert(UserInfoAuth {
        user_id: claims.sub,
        user_rol: claims.user_rol,
    });

    let response = next.run(request).await;

    Ok(response)
}
--- http_api/src/category_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{delete, get, post, put},
    Json, Router,
};
use entities::{
    category::{Category, CategoryCreation, CategoryRequirement},
    user::UserCategory,
};
use tracing::error;
use use_cases::category_service::{err::Error, CategoryService};
use uuid::Uuid;

use super::err::{HttpError, ToErrResponse};
use crate::err::HttpResult;

pub fn category_router(category_service: CategoryService) -> Router {
    Router::new()
        .route("/health-category", get(alive))
        .route(
            "/categories",
            post(create_category)
                .get(list_categories)
                .put(update_category),
        )
        .route(
            "/categories/{id}",
            get(get_category).delete(delete_category),
        )
        .route(
            "/categories/{id}/requirements",
            post(add_requirement).get(get_requirements),
        )
        .route("/categories/{id}/users/{user_id}", get(get_user_category))
        .with_state(category_service)
}

async fn alive() -> &'static str {
    "Category service is alive"
}

async fn create_category(
    State(category_service): State<CategoryService>,
    Json(category): Json<CategoryCreation>,
) -> HttpResult<impl IntoResponse> {
    category_service
        .add_category(category)
        .await
        .http_err("create category")?;

    Ok((StatusCode::OK, "Category created successfully"))
}

async fn get_category(
    State(category_service): State<CategoryService>,
    Path(id): Path<Uuid>,
) -> HttpResult<Json<Category>> {
    let category = category_service
        .get_category_by_id(id)
        .await
        .http_err("get category")?;

    Ok(Json(category))
}

async fn update_category(
    State(category_service): State<CategoryService>,
    Json(category): Json<Category>,
) -> Result<Json<Category>, Response> {
    category_service
        .update_category(&category)
        .await
        .http_err("update category")?;

    Ok(Json(category))
}

async fn delete_category(
    State(category_service): State<CategoryService>,
    Path(id): Path<Uuid>,
) -> Result<Json<String>, Response> {
    category_service
        .delete_category(id)
        .await
        .http_err("delete category")?;

    Ok(Json("Category deleted successfully".to_string()))
}

async fn list_categories(
    State(category_service): State<CategoryService>,
) -> Result<Json<Vec<Category>>, Response> {
    let categories = category_service
        .get_all_categories()
        .await
        .http_err("list categories")?;

    Ok(Json(categories))
}

async fn add_requirement(
    State(category_service): State<CategoryService>,
    Json(requirement): Json<CategoryRequirement>,
) -> Result<Json<CategoryRequirement>, Response> {
    category_service
        .add_category_requirement(&requirement)
        .await
        .http_err("add requirement")?;

    Ok(Json(requirement))
}

async fn get_requirements(
    State(category_service): State<CategoryService>,
    Path(category_id): Path<Uuid>,
) -> Result<Json<Vec<CategoryRequirement>>, Response> {
    let requirements = category_service
        .get_category_requirements(category_id)
        .await
        .http_err("get requirements")?;

    Ok(Json(requirements))
}

async fn get_user_category(
    State(category_service): State<CategoryService>,
    Path((category_id, user_id)): Path<(Uuid, Uuid)>,
) -> Result<Json<Option<UserCategory>>, Response> {
    let user_category = category_service
        .get_user_category(user_id, category_id)
        .await
        .http_err("get user category")?;

    Ok(Json(user_category))
}

impl<T> HttpError<T> for use_cases::category_service::err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::CategoryNotFound => "Category not found",
                Error::CategoryAlreadyExists => "Category already exists",
                Error::InvalidAgeRange => "Invalid age range",
                Error::MissingName => "Category name is required",
                Error::RequirementNotFound => "Category requirement not found",
                Error::UserAlreadyHasCategory => "User already has this category",
                Error::UserDoesNotMeetRequirements => "User does not meet category requirements",
                Error::LevelNotFound => "Level not found",
                Error::InvalidUserAge => {
                    "The age of the user is not between the specified category range"
                }
                Error::InvalidRequirementLevel => {
                    "The user don't have the necesary level in one of it's category requirements"
                }
                Error::UserServiceError(error) => "Error with the user service",
            }
            .to_err_response()
        })
    }
}
--- http_api/src/err.rs ---
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};

pub type HttpResult<T> = std::result::Result<T, Response>;

pub trait HttpError<T> {
    fn http_err(self, endpoint: &str) -> HttpResult<T>;
}

pub trait ToErrResponse {
    fn to_err_response(self) -> Response;
}

impl ToErrResponse for &str {
    fn to_err_response(self) -> Response {
        (StatusCode::INTERNAL_SERVER_ERROR, self.to_string()).into_response()
    }
}

impl ToErrResponse for String {
    fn to_err_response(self) -> Response {
        (StatusCode::INTERNAL_SERVER_ERROR, self.to_string()).into_response()
    }
}
--- http_api/src/main.rs ---
use std::{
    future::Future,
    net::{Ipv4Addr, SocketAddrV4},
    sync::Arc,
};

use auth::auth_middleware;
use axum::{
    body::Body,
    extract::{Request, State},
    http::StatusCode,
    middleware::{self, FromFnLayer, Next},
    response::IntoResponse,
    Router,
};
use request_endpoints::request_router;
use serde::Deserialize;
use tower_http::cors::CorsLayer;
use tower_http::trace::TraceLayer;
use tracing::{error, info};
use training_endpoints::training_router;
use tuition_endpoints::tuition_router;
use turso_db::TursoDb;
use use_cases::{
    category_service::CategoryService, request_service::RequestService,
    tournament_service::TournamentService, training_service::TrainingService,
    tuition_service::TuitionService, user_service::UserService,
};

mod auth;
mod category_endpoints;
mod err;
mod request_endpoints;
mod tournament_endpoints;
mod training_endpoints;
mod tuition_endpoints;
mod user_endpoints;

#[derive(Debug, Deserialize)]
struct Config {
    db_url: String,
    db_token: String,
    port: u16,
    token_key: String,
}

#[tokio::main]
async fn main() {
    let _ = dotenvy::dotenv();
    tracing_subscriber::fmt::init();

    let config: Config = envy::from_env().expect("Error generating config with the .env file");

    let mut main_router = Router::new();

    let turso_db = TursoDb::from(&config.db_url, &config.db_token)
        .await
        .inspect_err(|err| error!("Error creating turso db: {err}"))
        .expect("Error creating turso db");

    let password_hasher = bcrypt_hasher::BcryptHasher;

    let user_service = UserService::new(Arc::new(turso_db.clone()), Arc::new(password_hasher));

    let category_service = CategoryService::new(
        Arc::new(turso_db.clone()),
        Arc::new(turso_db.clone()),
        Arc::new(turso_db.clone()),
        user_service.clone(),
    );

    let tournament_service = TournamentService::new(
        Arc::new(turso_db.clone()),
        Arc::new(turso_db.clone()),
        Arc::new(turso_db.clone()),
        category_service.clone(),
    );

    let request_service = RequestService::new(Arc::new(turso_db.clone()));

    let tuition_service = TuitionService::new(Arc::new(turso_db.clone()));

    let training_service = TrainingService::new(
        Arc::new(turso_db.clone()),
        Arc::new(turso_db.clone()),
        category_service.clone(),
    );

    main_router = main_router
        .merge(user_endpoints::user_router(user_service, &config.token_key))
        .merge(tournament_endpoints::tournament_router(tournament_service))
        .merge(category_endpoints::category_router(category_service))
        .merge(training_router(training_service))
        .merge(request_router(request_service))
        .merge(tuition_router(tuition_service, config.token_key));

    let cors_layer = CorsLayer::permissive();

    main_router = main_router
        .layer(cors_layer)
        .layer(TraceLayer::new_for_http());

    let addr = SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), config.port);

    info!("Starting server in the addr: {addr}");

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();

    axum::serve(listener, main_router).await.unwrap();
}
--- http_api/src/request_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post},
    Extension, Json, Router,
};
use entities::request::{Request, RequestCreation};
use tracing::error;
use use_cases::request_service::{err::Error, RequestService};
use uuid::Uuid;

use super::err::{HttpError, ToErrResponse};
use crate::{auth::UserInfoAuth, err::HttpResult};

pub fn request_router(request_service: RequestService) -> Router {
    Router::new()
        .route("/health-request", get(alive))
        .route("/requests", post(create_request).get(list_requests))
        .route("/requests/{id}", get(get_request))
        .route("/requests/{id}/complete/{approved}", post(complete_request))
        .route("/requests/user/{user_id}", get(list_user_requests))
        .with_state(request_service)
}

async fn alive() -> &'static str {
    "Request service is alive"
}

async fn create_request(
    State(request_service): State<RequestService>,
    Json(request): Json<RequestCreation>,
) -> HttpResult<impl IntoResponse> {
    request_service
        .create_request(
            request.requester_id,
            request.requested_command,
            request.justification,
        )
        .await
        .http_err("create request")?;

    Ok((StatusCode::CREATED, "Request created successfully"))
}

async fn get_request(
    State(request_service): State<RequestService>,
    Path(id): Path<Uuid>,
) -> HttpResult<Json<Request>> {
    let request = request_service
        .get_request_by_id(id)
        .await
        .http_err("get request")?
        .ok_or(Error::RequestNotFound)
        .http_err("get request")?;

    Ok(Json(request))
}

async fn complete_request(
    State(request_service): State<RequestService>,
    Path((id, approved)): Path<(Uuid, bool)>,
    Extension(user_info): Extension<UserInfoAuth>,
) -> HttpResult<impl IntoResponse> {
    request_service
        .complete_request(id, user_info.user_id, approved)
        .await
        .http_err("complete request")?;

    Ok((StatusCode::OK, "Request completed successfully"))
}

async fn list_requests(
    State(request_service): State<RequestService>,
) -> HttpResult<Json<Vec<Request>>> {
    let requests = request_service
        .list_requests()
        .await
        .http_err("list requests")?;

    Ok(Json(requests))
}

async fn list_user_requests(
    State(request_service): State<RequestService>,
    Path(user_id): Path<Uuid>,
) -> HttpResult<Json<Vec<Request>>> {
    let requests = request_service
        .list_user_requests(user_id)
        .await
        .http_err("list user requests")?;

    Ok(Json(requests))
}

impl<T> HttpError<T> for use_cases::request_service::err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::RequestNotFound => "Request not found",
                Error::RequestAlreadyCompleted => "Request already completed",
                Error::SelfApprovalNotAllowed => "Cannot approve/reject your own request",
                Error::InvalidApprover => "Invalid approver ID",
            }
            .to_err_response()
        })
    }
}
--- http_api/src/tournament_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{get, post, put},
    Json, Router,
};
use entities::tournament::{
    Tournament, TournamentAttendance, TournamentCreation, TournamentRegistration,
};
use tracing::error;
use use_cases::tournament_service::{err::Error, TournamentService};
use uuid::Uuid;

use crate::err::{HttpError, HttpResult, ToErrResponse};

pub fn tournament_router(tournament_service: TournamentService) -> Router {
    Router::new()
        .route("/health-tournament", get(alive))
        .route(
            "/tournaments",
            post(create_tournament).get(list_tournaments),
        )
        .route(
            "/tournaments/{id}",
            get(get_tournament)
                .put(update_tournament)
                .delete(delete_tournament),
        )
        .route("/tournaments/{id}/register", post(register_user))
        .route("/tournaments/{id}/attendance", post(record_attendance))
        .route("/tournaments/{id}/position", put(update_position))
        .route(
            "/users/{id}/eligible-tournaments",
            get(get_eligible_tournaments),
        )
        .with_state(tournament_service)
}

async fn alive() -> &'static str {
    "Tournament service is alive"
}

async fn create_tournament(
    State(tournament_service): State<TournamentService>,
    Json(tournament): Json<TournamentCreation>,
) -> HttpResult<impl IntoResponse> {
    tournament_service
        .create_tournament(tournament)
        .await
        .http_err("create tournament")?;

    Ok((StatusCode::OK, "Tournament created successfully"))
}

async fn get_tournament(
    State(tournament_service): State<TournamentService>,
    Path(id): Path<Uuid>,
) -> Result<Json<Tournament>, Response> {
    let tournament = tournament_service
        .get_tournament(id)
        .await
        .http_err("get tournament")?;

    Ok(Json(tournament))
}

async fn update_tournament(
    State(tournament_service): State<TournamentService>,
    Json(tournament): Json<Tournament>,
) -> Result<(), Response> {
    tournament_service
        .update_tournament(tournament)
        .await
        .http_err("update tournament")?;

    Ok(())
}

async fn delete_tournament(
    State(tournament_service): State<TournamentService>,
    Path(id): Path<Uuid>,
) -> Result<Json<String>, Response> {
    tournament_service
        .delete_tournament(id)
        .await
        .http_err("delete tournament")?;

    Ok(Json("Tournament deleted successfully".to_string()))
}

async fn list_tournaments(
    State(tournament_service): State<TournamentService>,
) -> Result<Json<Vec<Tournament>>, Response> {
    let tournaments = tournament_service
        .list_tournaments()
        .await
        .http_err("list tournaments")?;

    let tournaments_dto = tournaments.into_iter().collect();
    Ok(Json(tournaments_dto))
}

async fn register_user(
    State(tournament_service): State<TournamentService>,
    Json(registration): Json<TournamentRegistration>,
) -> Result<Json<String>, Response> {
    tournament_service
        .register_user(registration)
        .await
        .http_err("register user")?;

    Ok(Json("User registered successfully".to_string()))
}

async fn record_attendance(
    State(tournament_service): State<TournamentService>,
    Json(attendance): Json<TournamentAttendance>,
) -> Result<Json<String>, Response> {
    tournament_service
        .record_attendance(attendance)
        .await
        .http_err("record attendance")?;

    Ok(Json("Attendance recorded successfully".to_string()))
}

async fn get_eligible_tournaments(
    State(tournament_service): State<TournamentService>,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<Tournament>>, Response> {
    let tournaments = tournament_service
        .get_eligible_tournaments(user_id)
        .await
        .http_err("get eligible tournaments")?;

    Ok(Json(tournaments))
}

async fn update_position(
    State(tournament_service): State<TournamentService>,
    Path((tournament_id, user_id)): Path<(Uuid, Uuid)>,
    Json(position): Json<i32>,
) -> Result<Json<String>, Response> {
    tournament_service
        .update_position(tournament_id, user_id, position)
        .await
        .http_err("update position")?;

    Ok(Json("Position updated successfully".to_string()))
}

impl<T> HttpError<T> for use_cases::tournament_service::err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::TournamentNotFound => "Tournament not found",
                Error::UserNotRegistered => "User not registered for tournament",
                Error::UserAlreadyRegistered => "User already registered",
                Error::InvalidDates => "Invalid tournament dates",
                Error::InvalidCategory => "Invalid category",
                Error::NegativePosition => "Position must be positive",
                Error::PositionAlreadyTaken => "Position already taken",
                Error::UserDidNotAttend => "User did not attend tournament",
                Error::UserDoesNotMeetCategoryRequirements => {
                    "User is not part of the category required to join the tournament"
                }
                Error::CategoryServiceError(error) => "Error in the category service",
            }
            .to_err_response()
        })
    }
}
--- http_api/src/training_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{get, post, put},
    Json, Router,
};
use entities::training::{Training, TrainingCreation, TrainingRegistration};
use tracing::error;
use use_cases::training_service::{err::Error, TrainingService};
use uuid::Uuid;

use crate::err::{HttpError, HttpResult, ToErrResponse};

pub fn training_router(training_service: TrainingService) -> Router {
    Router::new()
        .route("/health-training", get(alive))
        .route("/trainings", post(create_training).get(list_trainings))
        .route(
            "/trainings/{id}",
            get(get_training)
                .put(update_training)
                .delete(delete_training),
        )
        .route("/trainings/{id}/register", post(register_user))
        .route("/trainings/{id}/attendance", post(mark_attendance))
        .route(
            "/users/{id}/eligible-trainings",
            get(get_eligible_trainings),
        )
        .with_state(training_service)
}

async fn alive() -> &'static str {
    "Training service is alive"
}

async fn create_training(
    State(training_service): State<TrainingService>,
    Json(training): Json<TrainingCreation>,
) -> HttpResult<impl IntoResponse> {
    training_service
        .create_training(&training)
        .await
        .http_err("create training")?;

    Ok((StatusCode::OK, "Training created successfully"))
}

async fn get_training(
    State(training_service): State<TrainingService>,
    Path(id): Path<Uuid>,
) -> Result<Json<Training>, Response> {
    let training = training_service
        .get_training(id)
        .await
        .http_err("get training")?;

    Ok(Json(training))
}

async fn update_training(
    State(training_service): State<TrainingService>,
    Json(training): Json<Training>,
) -> Result<(), Response> {
    training_service
        .update_training(&training)
        .await
        .http_err("update training")?;

    Ok(())
}

async fn delete_training(
    State(training_service): State<TrainingService>,
    Path(id): Path<Uuid>,
) -> Result<Json<String>, Response> {
    training_service
        .delete_training(id)
        .await
        .http_err("delete training")?;

    Ok(Json("Training deleted successfully".to_string()))
}

async fn list_trainings(
    State(training_service): State<TrainingService>,
) -> Result<Json<Vec<Training>>, Response> {
    let trainings = training_service
        .list_trainings()
        .await
        .http_err("list trainings")?;

    Ok(Json(trainings))
}

async fn register_user(
    State(training_service): State<TrainingService>,
    Json(registration): Json<TrainingRegistration>,
) -> Result<Json<String>, Response> {
    training_service
        .register_user(registration)
        .await
        .http_err("register user")?;

    Ok(Json("User registered successfully".to_string()))
}

async fn mark_attendance(
    State(training_service): State<TrainingService>,
    Path((training_id, user_id)): Path<(Uuid, Uuid)>,
    Json(attended): Json<bool>,
) -> Result<Json<String>, Response> {
    training_service
        .mark_attendance(training_id, user_id, attended)
        .await
        .http_err("mark attendance")?;

    Ok(Json("Attendance marked successfully".to_string()))
}

async fn get_eligible_trainings(
    State(training_service): State<TrainingService>,
    Path(user_id): Path<Uuid>,
) -> Result<Json<Vec<Training>>, Response> {
    let trainings = training_service
        .get_eligible_trainings(user_id)
        .await
        .http_err("get eligible trainings")?;

    Ok(Json(trainings))
}

impl<T> HttpError<T> for use_cases::training_service::err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::TrainingNotFound => "Training not found",
                Error::UserAlreadyRegistered => "User already registered for this training",
                Error::UserDoesNotMeetCategoryRequirements => {
                    "User does not meet category requirements for this training"
                }
                Error::InvalidDates => "Invalid training dates",
                Error::UserNotRegistered => "User not registered for this training",
                Error::RegistrationNotFound => "Training registration not found",
                Error::CategoryServiceError(_) => "Error in the category service",
            }
            .to_err_response()
        })
    }
}
--- http_api/src/tuition_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    middleware,
    response::IntoResponse,
    routing::{get, post},
    Extension, Json, Router,
};
use entities::tuition::Tuition;
use tracing::error;
use use_cases::tuition_service::{err::Error, TuitionService};
use uuid::Uuid;

use super::err::{HttpError, ToErrResponse};
use crate::{
    auth::{auth_middleware, UserInfoAuth},
    err::HttpResult,
};

pub fn tuition_router(tuition_service: TuitionService, jwt_key: String) -> Router {
    Router::new()
        .route("/health-tuition", get(alive))
        .route("/tuitions/pay/{amount}", post(pay_tuition))
        .route("/tuitions", get(list_tuitions))
        .route("/tuitions/{user_id}", get(list_user_tuitions))
        .route("/tuitions/active/{user_id}", get(has_active_tuition))
        .layer(middleware::from_fn_with_state(jwt_key, auth_middleware))
        .with_state(tuition_service)
}

async fn alive() -> &'static str {
    "Tuition service is alive"
}
async fn pay_tuition(
    State(tuition_service): State<TuitionService>,
    Path(amount): Path<f64>,
    Extension(user_info): Extension<UserInfoAuth>,
) -> HttpResult<impl IntoResponse> {
    tuition_service
        .pay_tuition(user_info.user_id, amount)
        .await
        .http_err("pay tuition")?;

    Ok((StatusCode::CREATED, "Tuition payment recorded successfully"))
}

async fn list_tuitions(
    State(tuition_service): State<TuitionService>,
) -> HttpResult<Json<Vec<Tuition>>> {
    let tuitions = tuition_service
        .get_all_tuitions()
        .await
        .http_err("list tuitions")?;

    Ok(Json(tuitions))
}

async fn list_user_tuitions(
    State(tuition_service): State<TuitionService>,
    Path(user_id): Path<Uuid>,
) -> HttpResult<Json<Vec<Tuition>>> {
    let tuitions = tuition_service
        .get_user_tuitions(user_id)
        .await
        .http_err("list user tuitions")?;

    Ok(Json(tuitions))
}

async fn has_active_tuition(
    State(tuition_service): State<TuitionService>,
    Path(user_id): Path<Uuid>,
) -> HttpResult<Json<bool>> {
    let has_active = tuition_service
        .has_active_tuition(user_id)
        .await
        .http_err("check active tuition")?;

    Ok(Json(has_active))
}

impl<T> HttpError<T> for use_cases::tuition_service::err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::ActiveTuitionExists => "Active tuition already exists",
                Error::InvalidAmount => "Invalid payment amount",
                Error::TuitionNotFound => "Tuition not found",
            }
            .to_err_response()
        })
    }
}
--- http_api/src/user_endpoints.rs ---
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse, Response},
    routing::{get, post, put},
    Json, Router,
};

use super::err::ToErrResponse;

use entities::user::{URol, UserCreation, UserInfo, UserLogInInfo};
use serde::{Deserialize, Serialize};
use tracing::error;
use use_cases::user_service::{
    err::{self, Error},
    UserService,
};
use uuid::Uuid;

use crate::{
    auth::generate_jwt,
    err::{HttpError, HttpResult},
};

pub fn user_router(user_service: UserService, token_key: &str) -> Router {
    Router::new()
        .route("/health-user", get(alive))
        .route("/register", post(register_user))
        .route("/logIn", post(log_in_user))
        .route("/users", get(get_all_users))
        .route("/users/{id}", get(get_user_by_id))
        .route("/update/{id}", put(update_user))
        .with_state((user_service, token_key.to_string()))
}

async fn get_all_users(
    State((user_service, _)): State<(UserService, String)>,
) -> Result<Json<Vec<UserInfo>>, Response> {
    let users = user_service
        .get_all_users()
        .await
        .http_err("get all users")?;

    Ok(Json(users))
}
async fn get_user_by_id(
    State((user_service, _)): State<(UserService, String)>,
    Path(user_id): Path<Uuid>,
) -> Result<Json<UserInfo>, Response> {
    let user = user_service
        .get_user_by_id(user_id)
        .await
        .http_err("get user by id")?;

    Ok(Json(user))
}

async fn update_user(
    State((user_service, _)): State<(UserService, String)>,
    Path(user_id): Path<Uuid>,
    Json(user_update): Json<UserCreation>,
) -> HttpResult<impl IntoResponse> {
    user_service
        .update_user(user_id, user_update)
        .await
        .http_err("update user")?;

    Ok((StatusCode::OK, "User updated successfully"))
}

async fn alive() -> Result<Json<String>, Response> {
    Ok(Json("I am alive".to_string()))

    // Example Error Err((StatusCode::INTERNAL_SERVER_ERROR, error_message))
}

#[derive(Deserialize, Serialize, Clone, Debug)]
struct LogInResponse {
    token: String,
    user_id: Uuid,
    user_rol: URol,
}

async fn log_in_user(
    State((user_service, token_key)): State<(UserService, String)>,
    Json(user_log_in_info): Json<UserLogInInfo>,
) -> Result<Json<LogInResponse>, Response> {
    let log_in_response = user_service
        .log_in_user(&user_log_in_info)
        .await
        .http_err("log in user")?;

    let token = generate_jwt(&log_in_response, &token_key).http_err("log in user")?;

    Ok(Json(LogInResponse {
        token,
        user_id: log_in_response.user_id,
        user_rol: log_in_response.user_rol,
    }))
}

async fn register_user(
    State((user_service, _)): State<(UserService, String)>,
    Json(user_creation): Json<UserCreation>,
) -> HttpResult<impl IntoResponse> {
    user_service
        .register_user(user_creation)
        .await
        .http_err("register user")?;

    Ok((StatusCode::OK, "User added succesfully"))
}

impl<T> HttpError<T> for Result<T, jsonwebtoken::errors::Error> {
    fn http_err(self, endpoint: &str) -> HttpResult<T> {
        self.map_err(|err| {
            format!("{endpoint}: Error with json web token: {err}").to_err_response()
        })
    }
}

impl<T> HttpError<T> for err::Result<T> {
    fn http_err(self, endpoint_name: &str) -> crate::err::HttpResult<T> {
        self.map_err(|err| {
            error!("Error in: {endpoint_name}");
            match err {
                Error::UnknownDatabaseError(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::UserIdDontExist => "Unable to find user with the provided id",
                Error::ErrorHashing(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::ErrorVerificationHash(error) => {
                    error!("{error}");
                    "We are having problems in the server, try again"
                }
                Error::InvalidPassword => "The password is invalid, try again",
                Error::EmailAlreadyExists => "Email is already in use, try with other email",
                Error::PhoneAlreadyExists => "Phone is already in use, try with other phone",
                Error::DocumentAlreadyExists => {
                    "Document is already in use, try with other document"
                }
                Error::InvalidIdentifier => {
                    "There is not an user registered with the provided identifier"
                }
            }
            .to_err_response()
        })
    }
}
--- turso_db/src/category_repo/mod.rs ---
use async_trait::async_trait;
use entities::category::{Category, CategoryRequirement, Level};
use entities::user::UserCategory;
use libsql::{de, params};
use use_cases::category_service::err::{Error, Result};
use use_cases::category_service::repository_trait::{
    CategoryRepository, CategoryRequirementRepository, LevelRepository, UserCategoryRepository,
};

use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl CategoryRequirementRepository for TursoDb {
    async fn create_category_requirement(&self, requirement: &CategoryRequirement) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        conn.execute("INSERT INTO category_requirement (id_category_requirement, id_category, requirement_description,
required_level, deleted) VALUES (?1, ?2, ?3, ?4, ?5)",
            params![requirement.id_category_requirement.to_string(), requirement.id_category.to_string(),
                requirement.requirement_description.to_string(),
            requirement.required_level.to_string()]).await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn get_category_requirements(
        &self,
        category_id: Uuid,
    ) -> Result<Vec<CategoryRequirement>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_category_requirement, id_category, requirement_description, required_level, deleted 
FROM category_requirement
WHERE deleted = 0 AND id_category = ?1",
                params![category_id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut res: Vec<CategoryRequirement> = Vec::new();

        while let Some(res_row) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            res.push(
                de::from_row::<CategoryRequirement>(&res_row)
                    .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?,
            );
        }

        Ok(res)
    }
}

#[async_trait]
impl UserCategoryRepository for TursoDb {
    async fn get_user_category(
        &self,
        id_user: Uuid,
        id_category: Uuid,
    ) -> Result<Option<UserCategory>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_category, id_user, user_level FROM user_category WHERE id_category = ?1 AND id_user = ?2 AND deleted = 0",
                params![id_user.to_string(), id_category.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        if let Some(rows_res) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            let category = de::from_row::<UserCategory>(&rows_res)
                .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;
            return Ok(Some(category));
        }
        Ok(None)
    }

    async fn user_has_category(&self, id_user: Uuid, id_category: Uuid) -> Result<bool> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT 1 FROM user_category WHERE id_category = ?1 AND id_user = ?2 AND deleted = 0",
                params![id_user.to_string(), id_category.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
            .is_some())
    }

    async fn create_user_category(&self, user_category: &UserCategory) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        conn.execute(
            "INSERT INTO user_category (id_user, id_category, user_level, deleted) VALUES (?1, ?2, ?3, 0)",
            params![
                user_category.id_user.to_string(),
                user_category.id_category.to_string(),
                user_category.user_level.to_string()
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn get_user_categories(&self, user_id: Uuid) -> Result<Vec<UserCategory>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_user, id_category, user_level 
                 FROM user_category 
                 WHERE id_user = ?1 AND deleted = 0",
                params![user_id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut categories = Vec::new();

        while let Some(row) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            let category = de::from_row::<UserCategory>(&row)
                .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;
            categories.push(category);
        }

        Ok(categories)
    }
}

#[async_trait]
impl LevelRepository for TursoDb {
    async fn create_level(&self, level: &Level) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;
        conn.execute(
            "INSERT INTO level (level_name) VALUES (?1)",
            params![level.level_name.to_string()],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn get_level_by_id(&self, id: Uuid) -> Result<Option<Level>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT level_name FROM level WHERE level_name = ?1",
                params![id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        if let Some(rows_res) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            let level = de::from_row::<Level>(&rows_res)
                .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;
            return Ok(Some(level));
        }
        Ok(None)
    }

    async fn list_levels(&self) -> Result<Vec<Level>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query("SELECT id_level, name FROM level", params![])
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut res: Vec<Level> = Vec::new();

        while let Some(res_row) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            res.push(
                de::from_row::<Level>(&res_row)
                    .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?,
            );
        }

        Ok(res)
    }
}

#[async_trait]
impl CategoryRepository for TursoDb {
    async fn get_category_by_name(&self, name: &str) -> Result<Option<Category>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_category, name, min_age, max_age, deleted FROM category WHERE name = ?1 AND deleted = 0",
                params![name],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        if let Some(rows_res) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            let category = de::from_row::<Category>(&rows_res)
                .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;
            return Ok(Some(category));
        }
        Ok(None)
    }

    async fn create_category(&self, category: &Category) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        conn.execute(
            "INSERT INTO category (id_category, name, min_age, max_age) VALUES (?1, ?2, ?3, ?4)",
            params![
                category.id_category.to_string(),
                *category.name,
                category.min_age,
                category.max_age
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn get_category_by_id(&self, id: Uuid) -> Result<Option<Category>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_category, name, min_age, max_age, deleted FROM category WHERE id_category = ?1 AND deleted = 0",
                params![id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        if let Some(rows_res) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            let category = de::from_row::<Category>(&rows_res)
                .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

            return Ok(Some(category));
        }
        Ok(None)
    }

    async fn update_category(&self, category: &Category) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        conn.execute(
            "UPDATE category SET name = ?2, min_age = ?3, max_age = ?4 WHERE id_category = ?1",
            params![
                category.id_category.to_string(),
                *category.name,
                category.min_age,
                category.max_age
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn delete_category(&self, id: Uuid) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        conn.execute(
            "UPDATE category SET deleted = 1 WHERE id_category = ?1",
            params![id.to_string()],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        Ok(())
    }

    async fn list_categories(&self) -> Result<Vec<Category>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut rows = conn
            .query(
                "SELECT id_category, name, min_age, max_age, deleted FROM category WHERE deleted = 0",
                params![],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?;

        let mut res: Vec<Category> = Vec::new();

        while let Some(res_row) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?
        {
            res.push(
                de::from_row::<Category>(&res_row)
                    .map_err(|err| Error::UnknownDatabaseError(err.to_string()))?,
            );
        }

        Ok(res)
    }
}
--- turso_db/src/lib.rs ---
use std::{error::Error, sync::Arc};

use libsql::params;
use libsql::{de, params::IntoParams, Connection, Rows};
use serde::Deserialize;
use uuid::Uuid;

pub mod category_repo;
mod migration;
pub mod request_repo;
pub mod tournament_repo;
pub mod training_repo;
pub mod tuition_repo;
pub mod user_repo;

#[derive(Clone)]
pub struct TursoDb {
    db: Arc<libsql::Database>,
    conn: Option<Connection>,
}

impl TursoDb {
    pub async fn from(url: &str, token: &str) -> Result<TursoDb, Box<dyn Error>> {
        let db = libsql::Builder::new_remote(url.to_string(), token.to_string())
            .build()
            .await?;

        Ok(Self {
            db: Arc::new(db),
            conn: None,
        })
    }

    async fn get_connection(&self) -> Result<libsql::Connection, Box<dyn Error>> {
        match self.conn.clone() {
            Some(conn) => Ok(conn),
            None => Ok(self.db.connect()?),
        }
    }

    async fn get_connection_with_error<E>(
        &self,
        error_builder: impl Fn(String) -> E,
    ) -> Result<libsql::Connection, E> {
        match self.conn.clone() {
            Some(conn) => Ok(conn),
            None => Ok(self
                .db
                .connect()
                .map_err(|err| error_builder(format!("Error in connection: {err}"))))?,
        }
    }

    pub async fn query_one_with_error<T, E>(
        &self,
        sql: &str,
        params: impl IntoParams,
        error_builder: impl Fn(String) -> E,
    ) -> Result<Option<T>, E>
    where
        T: for<'de> Deserialize<'de>,
    {
        let conn = self.get_connection_with_error(&error_builder).await?;

        let rows = conn.query(sql, params).await;

        let value: Option<T> = self.get_value_from_row(rows, error_builder).await?;

        Ok(value)
    }

    pub async fn query_many_with_error<T, E>(
        &self,
        sql: &str,
        params: impl IntoParams,
        error_builder: impl Fn(String) -> E,
    ) -> Result<Vec<T>, E>
    where
        T: for<'de> Deserialize<'de>,
    {
        let conn = self.get_connection_with_error(&error_builder).await?;

        let rows = conn.query(sql, params).await;

        let value: Vec<T> = self.get_values_from_rows(rows, error_builder).await?;

        Ok(value)
    }

    pub async fn execute_with_error<E>(
        &self,
        sql: &str,
        params: impl IntoParams,
        error_builder: impl Fn(String) -> E,
    ) -> Result<(), E> {
        let conn = self.get_connection_with_error(&error_builder).await?;

        conn.execute(sql, params)
            .await
            .map_err(|err| error_builder(err.to_string()))?;

        Ok(())
    }

    pub async fn get_values_from_rows<T, E>(
        &self,
        rows: Result<Rows, libsql::Error>,
        error_builder: impl Fn(String) -> E,
    ) -> Result<Vec<T>, E>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut rows = rows.map_err(|err| error_builder(err.to_string()))?;

        let mut elements = Vec::new();

        while let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| error_builder(err.to_string()))?
        {
            let element =
                de::from_row::<T>(&row_result).map_err(|err| error_builder(err.to_string()))?;
            elements.push(element);
        }

        Ok(elements)
    }

    pub async fn create_test_user(&self, user_id: Uuid) -> Result<(), Box<dyn Error>> {
        self.conn
            .clone()
            .unwrap()
            .execute(
                "INSERT INTO person (
id_user, first_name, last_name, birth_date, registration_date,
email, email_verified, phone_number, country_code, password,
identification_number, identification_type, user_rol, deleted
) VALUES (?1, 'Test', 'User', '2000-01-01', '2023-01-01 00:00:00',
?2, 1, '123456789', 'CO', 'password',
'123456789', 'CC', 'USER', 0)",
                params![user_id.to_string(), format!("test{}@example.com", user_id)],
            )
            .await?;

        Ok(())
    }

    pub async fn get_value_from_row<T, E>(
        &self,
        rows: Result<Rows, libsql::Error>,
        error_builder: impl Fn(String) -> E,
    ) -> Result<Option<T>, E>
    where
        T: for<'de> Deserialize<'de>,
    {
        let mut rows = rows.map_err(|err| error_builder(err.to_string()))?;

        if let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| error_builder(err.to_string()))?
        {
            let element =
                de::from_row::<T>(&row_result).map_err(|err| error_builder(err.to_string()))?;

            Ok(Some(element))
        } else {
            Ok(None)
        }
    }
}

pub struct TestDbBuilder {
    db: Arc<libsql::Database>,
    conn: Connection,
}

impl TestDbBuilder {
    pub async fn create() -> Self {
        let db = libsql::Builder::new_local(":memory:")
            .build()
            .await
            .expect("Error building in memory db");

        let conn = db.connect().expect("Error getting connection");

        let turso_db = Self {
            db: Arc::new(db),
            conn: conn.clone(),
        };

        conn.execute_batch(&migration::get_migration())
            .await
            .expect("Error applying migration");

        println!("Migration applied successfully");

        turso_db
    }

    pub async fn create_full() -> TursoDb {
        Self::create()
            .await
            .apply_doc_types()
            .await
            .apply_user_roles()
            .await
            .build()
    }

    pub async fn print_tables(&self) {
        let conn = self.conn.clone();

        let mut rows = conn
            .query(
                "
SELECT name, sql
FROM sqlite_master
WHERE type = 'table';
",
                params![],
            )
            .await
            .expect("Error getting tables info");

        while let Some(row) = rows.next().await.unwrap() {
            let table_name = row.get_str(0).unwrap_or("Unknown table");
            let table_sql = row.get_str(1).unwrap_or("No SQL available");
            println!("Table: {}\nSQL: {}\n", table_name, table_sql);
        }
    }

    pub async fn apply_doc_types(self) -> Self {
        self.conn
            .execute(
                "INSERT INTO identification_type (identification_type, deleted) 
VALUES ('CC', false)",
                params![],
            )
            .await
            .unwrap();

        self
    }

    pub async fn apply_user_roles(self) -> Self {
        self.conn
            .execute(
                "INSERT INTO user_rol (user_rol, deleted) 
VALUES ('ADMIN', 0), ('USER', 0), ('TRAINER', 0)",
                params![],
            )
            .await
            .unwrap();

        self
    }

    pub async fn apply_levels(self) -> Self {
        self.conn
            .execute(
                "INSERT INTO user_rol (user_rol) 
VALUES ('BEGGINER'), ('AMATEUR'), ('PROFESSIONAL')",
                params![],
            )
            .await
            .unwrap();

        self
    }

    pub fn build(self) -> TursoDb {
        TursoDb {
            db: self.db,
            conn: Some(self.conn),
        }
    }
}
--- turso_db/src/migration.rs ---
pub fn get_migration() -> String {
    r#"
-- 1) user_rol
CREATE TABLE user_rol (
    user_rol       TEXT PRIMARY KEY,
    deleted        INTEGER NOT NULL DEFAULT 0  -- 0 = false, 1 = true
);

-- 2) identification_type
CREATE TABLE identification_type (
    identification_type  TEXT PRIMARY KEY,
    deleted             INTEGER NOT NULL DEFAULT 0
);

-- 3) category
CREATE TABLE category (
    id_category   TEXT PRIMARY KEY,
    name          TEXT NOT NULL,
    min_age       INTEGER NOT NULL,
    max_age       INTEGER NOT NULL,
    deleted       INTEGER NOT NULL DEFAULT 0
);

-- 4) level
CREATE TABLE level (
    level_name    TEXT PRIMARY KEY,
    deleted       INTEGER NOT NULL DEFAULT 0
);

-- 5) person
CREATE TABLE person (
    id_user                TEXT PRIMARY KEY,
    first_name             TEXT NOT NULL,
    last_name              TEXT NOT NULL,
    birth_date             TEXT NOT NULL,             -- Example: 'YYYY-MM-DD'
    registration_date      TEXT NOT NULL,             -- Example: 'YYYY-MM-DD HH:MM:SS'
    email                  TEXT NOT NULL UNIQUE,
    email_verified         INTEGER NOT NULL DEFAULT 0,  -- 0 = false, 1 = true
    phone_number           TEXT NOT NULL,
    country_code           TEXT NOT NULL,
    password               TEXT NOT NULL,
    identification_number  TEXT NOT NULL,
    identification_type    TEXT NOT NULL,
    user_rol               TEXT NOT NULL,
    deleted                INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (identification_type) REFERENCES identification_type(identification_type),
    FOREIGN KEY (user_rol) REFERENCES user_rol(user_rol)
);

-- 6) category_requirement
CREATE TABLE category_requirement (
    id_category_requirement   TEXT PRIMARY KEY,
    id_category               TEXT NOT NULL,
    requirement_description   TEXT,
    required_level            TEXT NOT NULL,
    deleted                   INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (id_category)    REFERENCES category(id_category),
    FOREIGN KEY (required_level) REFERENCES level(level_name)
);

-- 7) user_category
CREATE TABLE user_category (
    id_user      TEXT NOT NULL,
    id_category  TEXT NOT NULL,
    user_level   TEXT NOT NULL,
    deleted      INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (id_user, id_category),
    FOREIGN KEY (id_user)     REFERENCES person(id_user),
    FOREIGN KEY (id_category) REFERENCES category(id_category),
    FOREIGN KEY (user_level)  REFERENCES level(level_name)
);

-- 8) tournament
CREATE TABLE tournament (
    id_tournament  TEXT PRIMARY KEY,
    name           TEXT NOT NULL,
    id_category    TEXT NOT NULL,
    start_datetime TEXT NOT NULL,     -- Example: 'YYYY-MM-DD HH:MM:SS'
    end_datetime   TEXT NOT NULL,     -- Example: 'YYYY-MM-DD HH:MM:SS'
    deleted        INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (id_category) REFERENCES category(id_category)
);

-- 9) tournament_registration
CREATE TABLE tournament_registration (
    id_tournament        TEXT NOT NULL,
    id_user              TEXT NOT NULL,
    registration_datetime  TEXT NOT NULL,  -- Example: 'YYYY-MM-DD HH:MM:SS'
    deleted              INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (id_tournament, id_user),
    FOREIGN KEY (id_tournament) REFERENCES tournament(id_tournament),
    FOREIGN KEY (id_user)       REFERENCES person(id_user)
);

-- 10) tournament_attendance
CREATE TABLE tournament_attendance (
    id_tournament       TEXT NOT NULL,
    id_user             TEXT NOT NULL,
    attendance_datetime TEXT NOT NULL,   -- Example: 'YYYY-MM-DD HH:MM:SS'
    position            INTEGER NOT NULL,
    deleted             INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (id_tournament, id_user),
    FOREIGN KEY (id_tournament) REFERENCES tournament(id_tournament),
    FOREIGN KEY (id_user)       REFERENCES person(id_user)
);

-- 11) training
CREATE TABLE training (
    id_training    TEXT PRIMARY KEY,
    name           TEXT NOT NULL,
    id_category    TEXT NOT NULL,
    start_datetime TEXT NOT NULL,     -- Example: 'YYYY-MM-DD HH:MM:SS'
    end_datetime   TEXT NOT NULL,     -- Example: 'YYYY-MM-DD HH:MM:SS'
    minimum_payment REAL,
    deleted        INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (id_category) REFERENCES category(id_category)
);

-- 12) training_registration (updated: attendance_datetime is now nullable)
CREATE TABLE training_registration (
    id_training          TEXT NOT NULL,
    id_user              TEXT NOT NULL,
    registration_datetime TEXT NOT NULL,   -- Example: 'YYYY-MM-DD HH:MM:SS'
    attended             INTEGER NOT NULL DEFAULT 0,  -- 0 = false, 1 = true
    attendance_datetime  TEXT,              -- Changed to nullable
    deleted              INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (id_training, id_user),
    FOREIGN KEY (id_training) REFERENCES training(id_training),
    FOREIGN KEY (id_user)     REFERENCES person(id_user)
);

-- 13) tuition
CREATE TABLE tuition (
    id_tuition   TEXT PRIMARY KEY,
    id_user      TEXT NOT NULL,
    amount       REAL NOT NULL,
    payment_date TEXT NOT NULL,  -- Example: 'YYYY-MM-DD HH:MM:SS'
    deleted      INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (id_user) REFERENCES person(id_user)
);

-- 14) request_for_approval (new table)
CREATE TABLE request (
    request_id         TEXT PRIMARY KEY,
    requester_id       TEXT NOT NULL,
    requested_command  TEXT NOT NULL,
    justification      TEXT NOT NULL,
    approved           INTEGER,  -- Bool stored as INTEGER (0 = false, 1 = true)
    approver_id        TEXT,             -- Nullable, as approval may be pending
    deleted            INTEGER NOT NULL DEFAULT 0,  -- Added for consistency
    FOREIGN KEY (requester_id) REFERENCES person(id_user),
    FOREIGN KEY (approver_id)  REFERENCES person(id_user)
);
"#
    .to_string()
}
--- turso_db/src/request_repo/mod.rs ---
use async_trait::async_trait;
use entities::request::Request;
use libsql::params;
use use_cases::request_service::err::{Error, Result};
use use_cases::request_service::repository_trait::RequestRepository;
use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl RequestRepository for TursoDb {
    async fn create_request(&self, request: &Request) -> Result<()> {
        self.execute_with_error(
            "INSERT INTO request (
                request_id, requester_id, requested_command, justification, approved, approver_id
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
            params![
                request.request_id.to_string(),
                request.requester_id.to_string(),
                request.requested_command.clone(),
                request.justification.clone(),
                request.approved,
                request.approver_id.map(|id| id.to_string())
            ],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn get_request_by_id(&self, id: Uuid) -> Result<Option<Request>> {
        self.query_one_with_error(
            "SELECT request_id, requester_id, requested_command, justification, approved, approver_id 
             FROM request 
             WHERE request_id = ?1",
            params![id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn update_request(&self, request: &Request) -> Result<()> {
        self.execute_with_error(
            "UPDATE request SET 
                requester_id = ?1, 
                requested_command = ?2, 
                justification = ?3, 
                approved = ?4, 
                approver_id = ?5
             WHERE request_id = ?6",
            params![
                request.requester_id.to_string(),
                request.requested_command.clone(),
                request.justification.clone(),
                request.approved,
                request.approver_id.map(|id| id.to_string()),
                request.request_id.to_string()
            ],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn list_requests(&self) -> Result<Vec<Request>> {
        self.query_many_with_error(
            "SELECT request_id, requester_id, requested_command, justification, approved, approver_id 
             FROM request",
            params![],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn list_requests_by_user(&self, user_id: Uuid) -> Result<Vec<Request>> {
        self.query_many_with_error(
            "SELECT request_id, requester_id, requested_command, justification, approved, approver_id 
             FROM request 
             WHERE requester_id = ?1",
            params![user_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }
}

#[cfg(test)]
mod test {
    use std::future::Future;

    use super::*;
    use entities::request::Request;
    use rstest::{fixture, rstest};
    use uuid::Uuid;

    #[fixture]
    async fn repository() -> TursoDb {
        let db = crate::TestDbBuilder::create()
            .await
            .apply_doc_types()
            .await
            .apply_user_roles()
            .await
            .build();

        db
    }

    #[rstest]
    #[tokio::test]
    async fn test_create_and_get_request(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let request_id = Uuid::new_v4();
        let requester_id = Uuid::new_v4();

        db.create_test_user(requester_id)
            .await
            .expect("Error creating test user");

        let request = Request {
            request_id,
            requester_id,
            requested_command: "Test Command".to_string(),
            justification: "Test Justification".to_string(),
            approved: None,
            approver_id: None,
        };

        db.create_request(&request)
            .await
            .expect("Failed to create request");

        let retrieved_request = db
            .get_request_by_id(request_id)
            .await
            .expect("Failed to get request")
            .expect("Request not found");

        assert_eq!(request, retrieved_request);
    }

    #[rstest]
    #[tokio::test]
    async fn test_update_request(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let request_id = Uuid::new_v4();
        let requester_id = Uuid::new_v4();
        let approver_id = Uuid::new_v4();

        db.create_test_user(requester_id)
            .await
            .expect("Error creating test user");

        db.create_test_user(approver_id)
            .await
            .expect("Error creating test user");

        let mut request = Request {
            request_id,
            requester_id,
            requested_command: "Test Command".to_string(),
            justification: "Test Justification".to_string(),
            approved: None,
            approver_id: None,
        };

        db.create_request(&request)
            .await
            .expect("Failed to create request");

        // Update request
        request.approved = Some(true);
        request.approver_id = Some(approver_id);

        db.update_request(&request)
            .await
            .expect("Failed to update request");

        let updated_request = db
            .get_request_by_id(request_id)
            .await
            .expect("Failed to get request")
            .expect("Request not found");

        assert_eq!(request, updated_request);
    }

    #[rstest]
    #[tokio::test]
    async fn test_list_requests(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let requester_id = Uuid::new_v4();

        db.create_test_user(requester_id)
            .await
            .expect("Error creating test user");

        // Create 3 requests
        for i in 0..3 {
            let request = Request {
                request_id: Uuid::new_v4(),
                requester_id,
                requested_command: format!("Command {i}"),
                justification: format!("Justification {i}"),
                approved: None,
                approver_id: None,
            };

            db.create_request(&request)
                .await
                .expect("Failed to create request");
        }

        let requests = db.list_requests().await.expect("Failed to list requests");

        assert_eq!(requests.len(), 3);
    }

    #[rstest]
    #[tokio::test]
    async fn test_list_requests_by_user(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let user1_id = Uuid::new_v4();
        let user2_id = Uuid::new_v4();

        db.create_test_user(user1_id)
            .await
            .expect("Error creating test user");

        db.create_test_user(user2_id)
            .await
            .expect("Error creating test user");

        // Create 2 requests for user1
        for i in 0..2 {
            let request = Request {
                request_id: Uuid::new_v4(),
                requester_id: user1_id,
                requested_command: format!("Command {i}"),
                justification: format!("Justification {i}"),
                approved: None,
                approver_id: None,
            };

            db.create_request(&request)
                .await
                .expect("Failed to create request");
        }

        // Create 1 request for user2
        let request = Request {
            request_id: Uuid::new_v4(),
            requester_id: user2_id,
            requested_command: "Command".to_string(),
            justification: "Justification".to_string(),
            approved: None,
            approver_id: None,
        };

        db.create_request(&request)
            .await
            .expect("Failed to create request");

        // Test listing for user1
        let user1_requests = db
            .list_requests_by_user(user1_id)
            .await
            .expect("Failed to list requests");

        assert_eq!(user1_requests.len(), 2);

        // Test listing for user2
        let user2_requests = db
            .list_requests_by_user(user2_id)
            .await
            .expect("Failed to list requests");

        assert_eq!(user2_requests.len(), 1);
    }
}
--- turso_db/src/tournament_repo/mod.rs ---
use async_trait::async_trait;
use entities::tournament::{Tournament, TournamentAttendance, TournamentRegistration};
use libsql::{de, params};
use use_cases::tournament_service::err::{Error, Result};
use use_cases::tournament_service::repository_trait::{
    TournamentAttendanceRepository, TournamentRegistrationRepository, TournamentRepository,
};
use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl TournamentRepository for TursoDb {
    async fn create_tournament(&self, tournament: &Tournament) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "INSERT INTO tournament (
                id_tournament, name, id_category, start_datetime, end_datetime, deleted
            ) VALUES (?1, ?2, ?3, ?4, ?5, 0)",
            params![
                tournament.id_tournament.to_string(),
                tournament.name.to_string(),
                tournament.id_category.to_string(),
                tournament
                    .start_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                tournament
                    .end_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn get_tournament_by_id(&self, id: Uuid) -> Result<Option<Tournament>> {
        let conn = self
            .get_connection_with_error(Error::UnknownDatabaseError)
            .await?;

        let rows = conn
            .query(
                "SELECT id_tournament, name, id_category, start_datetime, end_datetime 
                 FROM tournament 
                 WHERE id_tournament = ?1 AND deleted = 0",
                params![id.to_string()],
            )
            .await;

        self.get_value_from_row(rows, Error::UnknownDatabaseError)
            .await
    }

    async fn update_tournament(&self, tournament: &Tournament) -> Result<()> {
        self.execute_with_error(
            "UPDATE tournament SET 
                name = ?1, 
                id_category = ?2, 
                start_datetime = ?3, 
                end_datetime = ?4
             WHERE id_tournament = ?5",
            params![
                tournament.name.to_string(),
                tournament.id_category.to_string(),
                tournament
                    .start_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                tournament
                    .end_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                tournament.id_tournament.to_string(),
            ],
            Error::UnknownDatabaseError,
        )
        .await
    }

    // async fn update_tournament(&self, tournament: &Tournament) -> Result<()> {
    //     let conn = self
    //         .get_connection()
    //         .await
    //         .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
    //
    //     conn.execute(
    //         "UPDATE tournament SET
    //             name = ?1,
    //             id_category = ?2,
    //             start_datetime = ?3,
    //             end_datetime = ?4,
    //             deleted = ?5
    //          WHERE id_tournament = ?6",
    //         params![
    //             tournament.name.to_string(),
    //             tournament.id_category.to_string(),
    //             tournament
    //                 .start_datetime
    //                 .format("%Y-%m-%d %H:%M:%S")
    //                 .to_string(),
    //             tournament
    //                 .end_datetime
    //                 .format("%Y-%m-%d %H:%M:%S")
    //                 .to_string(),
    //             tournament.deleted as i32,
    //             tournament.id_tournament.to_string(),
    //         ],
    //     )
    //     .await
    //     .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
    //
    //     Ok(())
    // }

    async fn delete_tournament(&self, id: Uuid) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "UPDATE tournament SET deleted = 1 WHERE id_tournament = ?1",
            params![id.to_string()],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn list_tournaments(&self) -> Result<Vec<Tournament>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_tournament, name, id_category, start_datetime, end_datetime 
                 FROM tournament 
                 WHERE deleted = 0",
                params![],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut tournaments = Vec::new();
        while let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let tournament = de::from_row::<Tournament>(&row_result)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            tournaments.push(tournament);
        }

        Ok(tournaments)
    }
}

#[async_trait]
impl TournamentRegistrationRepository for TursoDb {
    async fn register_user_for_tournament(
        &self,
        registration: &TournamentRegistration,
    ) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "INSERT INTO tournament_registration (
                id_tournament, id_user, registration_datetime
            ) VALUES (?1, ?2, ?3)",
            params![
                registration.id_tournament.to_string(),
                registration.id_user.to_string(),
                registration
                    .registration_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn get_tournament_registrations(
        &self,
        tournament_id: Uuid,
    ) -> Result<Vec<TournamentRegistration>> {
        self.query_many_with_error(
            "SELECT id_tournament, id_user, registration_datetime 
                FROM tournament_registration 
                WHERE id_tournament = ?1 AND deleted = 0",
            params![tournament_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    // async fn get_tournament_registrations(
    //     &self,
    //     tournament_id: Uuid,
    // ) -> Result<Vec<TournamentRegistration>> {
    //     let conn = self
    //         .get_connection()
    //         .await
    //         .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
    //
    //     let mut rows = conn
    //         .query(
    //             "SELECT id_tournament, id_user, registration_datetime
    //              FROM tournament_registration
    //              WHERE id_tournament = ?1 AND deleted = 0",
    //             params![tournament_id.to_string()],
    //         )
    //         .await
    //         .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
    //
    //     let mut registrations = Vec::new();
    //     while let Some(row_result) = rows
    //         .next()
    //         .await
    //         .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
    //     {
    //         let registration = de::from_row::<TournamentRegistration>(&row_result)
    //             .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
    //         registrations.push(registration);
    //     }
    //
    //     Ok(registrations)
    // }
}

#[async_trait]
impl TournamentAttendanceRepository for TursoDb {
    async fn record_tournament_attendance(&self, attendance: &TournamentAttendance) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "INSERT INTO tournament_attendance (
                id_tournament, id_user, attendance_datetime, position
            ) VALUES (?1, ?2, ?3, ?4)",
            params![
                attendance.id_tournament.to_string(),
                attendance.id_user.to_string(),
                attendance
                    .attendance_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                attendance.position,
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn get_tournament_attendance(
        &self,
        tournament_id: Uuid,
    ) -> Result<Vec<TournamentAttendance>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_tournament, id_user, attendance_datetime, position 
                 FROM tournament_attendance 
                 WHERE id_tournament = ?1 AND deleted = 0",
                params![tournament_id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut attendances = Vec::new();
        while let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let attendance = de::from_row::<TournamentAttendance>(&row_result)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            attendances.push(attendance);
        }

        Ok(attendances)
    }

    async fn update_tournament_position(
        &self,
        tournament_id: Uuid,
        user_id: Uuid,
        position: i32,
    ) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "UPDATE tournament_attendance SET position = ?1 
             WHERE id_tournament = ?2 AND id_user = ?3",
            params![position, tournament_id.to_string(), user_id.to_string()],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }
}

#[cfg(test)]
mod test {
    use std::future::Future;

    use entities::{
        category::Category,
        tournament::{Tournament, TournamentAttendance, TournamentRegistration},
        user::{URol, User},
    };
    use libsql::params;
    use rstest::{fixture, rstest};
    use use_cases::{
        category_service::repository_trait::{CategoryRepository, UserCategoryRepository},
        tournament_service::repository_trait::{
            TournamentAttendanceRepository, TournamentRegistrationRepository, TournamentRepository,
        },
        user_service::repository_trait::UserRepository,
    };
    use uuid::{uuid, Uuid};

    use crate::{TestDbBuilder, TursoDb};

    #[fixture]
    async fn repository() -> TursoDb {
        let db = TestDbBuilder::create()
            .await
            .apply_doc_types()
            .await
            .apply_user_roles()
            .await
            .apply_levels()
            .await
            .build();

        // Create a test user
        let user = User {
            id_user: Uuid::new_v4(),
            email: "test@example.com".to_string(),
            phone_number: "1234567890".to_string(),
            identification_number: "ID123456".to_string(),
            password: "password".to_string(),
            country_code: "CO".to_string(),
            identification_type: entities::user::IdType::CC,
            user_rol: URol::ADMIN,
            ..User::default()
        };

        db.create_user(&user)
            .await
            .expect("Failed to create test user");

        let conn = db.get_connection().await.expect("Failed to get connection");

        let category_id = uuid!("123e4567-e89b-12d3-a456-426614174000");

        let category = Category {
            name: "Test Category".into(),
            id_category: category_id,
            min_age: 10,
            max_age: 20,
        };

        db.create_category(&category)
            .await
            .expect("Error creating category");

        db.get_user_category(user.id_user, category_id)
            .await
            .expect("Error getting user category");

        let tournament_id = uuid!("25ab815d-8f40-48ff-9f75-06b2da90e2fc");

        let tournament = Tournament {
            id_tournament: tournament_id,
            name: "Tournament test".to_string(),
            id_category: uuid!("123e4567-e89b-12d3-a456-426614174000"),
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament)
            .await
            .expect("Error creating tournament");

        let user_id = uuid!("516e4310-720a-4d41-afa6-772426dc91ba");

        let user = User {
            id_user: user_id,
            email: "test_final@example.com".to_string(),
            phone_number: "123456789099".to_string(),
            identification_number: "ID123456h".to_string(),
            password: "passwordo".to_string(),
            country_code: "CO".to_string(),
            identification_type: entities::user::IdType::CC,
            user_rol: URol::ADMIN,
            ..User::default()
        };

        db.create_user(&user)
            .await
            .expect("Failed to create test user");

        db
    }

    #[rstest]
    #[tokio::test]
    async fn test_create_tournament(repository: impl Future<Output = TursoDb>) {
        let tournament_id = uuid!("67e55044-10b1-426f-9247-bb680e5fe0c8");
        let category_id = uuid!("123e4567-e89b-12d3-a456-426614174000");
        let db = repository.await;

        let tournament = Tournament {
            id_tournament: tournament_id,
            name: "Test Tournament".to_string(),
            id_category: category_id,
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament)
            .await
            .expect("Error creating tournament");

        let tournament_db = db
            .get_tournament_by_id(tournament_id)
            .await
            .expect("Error getting tournament by id")
            .expect("Tournament was not added");

        assert_eq!(tournament, tournament_db);
    }

    #[rstest]
    #[tokio::test]
    async fn test_get_tournament_by_id(repository: impl Future<Output = TursoDb>) {
        let tournament_id = Uuid::new_v4();
        let category_id = uuid!("123e4567-e89b-12d3-a456-426614174000");
        let db = repository.await;

        let tournament = Tournament {
            id_tournament: tournament_id,
            name: "Test Tournament".to_string(),
            id_category: category_id,
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament)
            .await
            .expect("Error creating tournament");

        let tournament_db = db
            .get_tournament_by_id(tournament_id)
            .await
            .expect("Error getting tournament by id")
            .expect("Tournament was not added");

        assert_eq!(tournament, tournament_db);

        let tournament_db = db
            .get_tournament_by_id(Uuid::new_v4())
            .await
            .expect("Error getting tournament by id");

        assert!(tournament_db.is_none());
    }

    #[rstest]
    #[tokio::test]
    async fn test_update_tournament(repository: impl Future<Output = TursoDb>) {
        let tournament_id = Uuid::new_v4();
        let category_id = uuid!("123e4567-e89b-12d3-a456-426614174000");
        let db = repository.await;

        let mut tournament = Tournament {
            id_tournament: tournament_id,
            name: "Original Name".to_string(),
            id_category: category_id,
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament)
            .await
            .expect("Error creating tournament");

        // Update some fields
        tournament.name = "Updated Name".to_string();
        tournament.end_datetime = chrono::DateTime::from_timestamp(172800, 0)
            .unwrap()
            .naive_utc();

        db.update_tournament(&tournament)
            .await
            .expect("Error updating tournament");

        let updated_tournament = db
            .get_tournament_by_id(tournament_id)
            .await
            .expect("Error fetching updated tournament")
            .expect("Tournament not found after update");

        assert_eq!(tournament, updated_tournament);
    }

    #[rstest]
    #[tokio::test]
    async fn test_delete_tournament(repository: impl Future<Output = TursoDb>) {
        let tournament_id = Uuid::new_v4();
        let category_id = uuid!("123e4567-e89b-12d3-a456-426614174000");
        let db = repository.await;

        let tournament = Tournament {
            id_tournament: tournament_id,
            name: "Test Tournament".to_string(),
            id_category: category_id,
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament)
            .await
            .expect("Error creating tournament");

        db.delete_tournament(tournament_id)
            .await
            .expect("Error deleting tournament");

        let deleted_tournament = db
            .get_tournament_by_id(tournament_id)
            .await
            .expect("Error fetching tournament after delete");

        assert!(deleted_tournament.is_none());
    }

    #[rstest]
    #[tokio::test]
    async fn test_list_tournaments(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;

        // Get initial list of tournaments
        let initial_tournaments = db
            .list_tournaments()
            .await
            .expect("Error listing initial tournaments");
        let initial_count = initial_tournaments.len();

        // Create two tournaments
        let tournament1 = Tournament {
            id_tournament: Uuid::new_v4(),
            name: "Tournament 1".to_string(),
            id_category: uuid!("123e4567-e89b-12d3-a456-426614174000"),
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        let tournament2 = Tournament {
            id_tournament: Uuid::new_v4(),
            name: "Tournament 2".to_string(),
            id_category: uuid!("123e4567-e89b-12d3-a456-426614174000"),
            start_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            end_datetime: chrono::DateTime::from_timestamp(86400, 0)
                .unwrap()
                .naive_utc(),
        };

        db.create_tournament(&tournament1)
            .await
            .expect("Error creating tournament1");
        db.create_tournament(&tournament2)
            .await
            .expect("Error creating tournament2");

        let tournaments_after_insert = db
            .list_tournaments()
            .await
            .expect("Error listing tournaments after insert");
        assert_eq!(tournaments_after_insert.len(), initial_count + 2);

        // Delete one tournament
        db.delete_tournament(tournament1.id_tournament)
            .await
            .expect("Error deleting tournament1");

        let tournaments_after_delete = db
            .list_tournaments()
            .await
            .expect("Error listing tournaments after deletion");
        assert_eq!(tournaments_after_delete.len(), initial_count + 1);

        // Ensure that tournament1 is no longer listed
        for tournament in tournaments_after_delete {
            assert_ne!(tournament.id_tournament, tournament1.id_tournament);
        }
    }

    #[rstest]
    #[tokio::test]
    async fn test_register_user_for_tournament(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;

        let tournament_id = uuid!("25ab815d-8f40-48ff-9f75-06b2da90e2fc");

        // Get the test user ID
        let user_id = db
            .get_user_id_by_email("test@example.com")
            .await
            .expect("Failed to get test user")
            .expect("Test user not found");

        let registration = TournamentRegistration {
            id_tournament: tournament_id,
            id_user: user_id,
            registration_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
        };

        db.register_user_for_tournament(&registration)
            .await
            .expect("Error registering user for tournament");

        let registrations = db
            .get_tournament_registrations(tournament_id)
            .await
            .expect("Error getting tournament registrations");

        assert_eq!(registrations.len(), 1);
        assert_eq!(registrations[0], registration);
    }

    #[rstest]
    #[tokio::test]
    async fn test_record_tournament_attendance(repository: impl Future<Output = TursoDb>) {
        let tournament_id = uuid!("25ab815d-8f40-48ff-9f75-06b2da90e2fc");
        let db = repository.await;

        // Get the test user ID
        let user_id = db
            .get_user_id_by_email("test@example.com")
            .await
            .expect("Failed to get test user")
            .expect("Test user not found");

        let attendance = TournamentAttendance {
            id_tournament: tournament_id,
            id_user: user_id,
            attendance_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            position: 1,
        };

        db.record_tournament_attendance(&attendance)
            .await
            .expect("Error recording tournament attendance");

        let attendances = db
            .get_tournament_attendance(tournament_id)
            .await
            .expect("Error getting tournament attendance");

        assert_eq!(attendances.len(), 1);
        assert_eq!(attendances[0], attendance);
    }

    #[rstest]
    #[tokio::test]
    async fn test_update_tournament_position(repository: impl Future<Output = TursoDb>) {
        let tournament_id = uuid!("25ab815d-8f40-48ff-9f75-06b2da90e2fc");
        let user_id = uuid!("516e4310-720a-4d41-afa6-772426dc91ba");
        let db = repository.await;

        let attendance = TournamentAttendance {
            id_tournament: tournament_id,
            id_user: user_id,
            attendance_datetime: chrono::DateTime::from_timestamp(0, 0).unwrap().naive_utc(),
            position: 1,
        };

        db.record_tournament_attendance(&attendance)
            .await
            .expect("Error recording tournament attendance");

        db.update_tournament_position(tournament_id, user_id, 2)
            .await
            .expect("Error updating tournament position");

        let attendances = db
            .get_tournament_attendance(tournament_id)
            .await
            .expect("Error getting tournament attendance");

        assert_eq!(attendances.len(), 1);
        assert_eq!(attendances[0].position, 2);
    }
}
--- turso_db/src/training_repo/mod.rs ---
use async_trait::async_trait;
use entities::training::{Training, TrainingRegistration};
use libsql::params;
use use_cases::training_service::{
    err::{Error, Result},
    repository_trait::{TrainingRegistrationRepository, TrainingRepository},
};
use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl TrainingRepository for TursoDb {
    async fn create_training(&self, training: &Training) -> Result<()> {
        self.execute_with_error("INSERT INTO 
training (id_training, name, start_datetime, end_datetime, minimum_payment, id_category) 
VALUES (id_training = 1?, name = 2?, start_datetime = 3?, end_datetime = 4?, minimum_payment = 5?, id_category = 6?)",
            params![
                training.id_training.to_string(),
                *training.name,
                training
                    .start_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                training
                    .end_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                training.minimum_payment,
                training.id_category.to_string()
            ],
 Error::UnknownDatabaseError).await
    }

    async fn get_training_by_id(&self, id: Uuid) -> Result<Option<Training>> {
        self.query_one_with_error(
            "SELECT id_training, name, start_datetime, end_datetime, minimum_payment, id_category
FROM training WHERE id_training = 1?",
            params![id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn update_training(&self, training: &Training) -> Result<()> {
        self.execute_with_error(
            "UPDATE training SET name = 2?, start_datetime = 3?, end_datetime = 4?,
minimum_payment = 5? = 6?, id_category = 7? WHERE id_training = 1?",
            params![
                training.id_training.to_string(),
                *training.name,
                training
                    .start_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                training
                    .end_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                training.minimum_payment,
                training.id_category.to_string()
            ],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn delete_training(&self, id: Uuid) -> Result<()> {
        self.execute_with_error(
            "UPDATE training SET deleted = 1 WHERE id_training = 1?",
            params![id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn list_trainings(&self) -> Result<Vec<Training>> {
        self.query_many_with_error("SELECT id_training, name, start_datetime, end_datetime, minimum_payment, id_category FROM
training", params![], Error::UnknownDatabaseError).await
    }
}

#[async_trait]
impl TrainingRegistrationRepository for TursoDb {
    async fn register_user_for_training(&self, registration: &TrainingRegistration) -> Result<()> {
        self.execute_with_error("INSERT INTO training_registration (id_user, registration_datetime, attended, attendance_time, id_training)
VALUES (id_user = 1?, registration_datetime = 2?, attended = 3?, attendance_time = 4?, id_training = 5? = 6?)", params![
    registration.id_user.to_string(),
    registration.registration_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
    registration.attended,
    registration.attendance_datetime
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
    registration.id_training.to_string(),
], Error::UnknownDatabaseError).await
    }

    async fn get_training_registrations(
        &self,
        training_id: Uuid,
    ) -> Result<Vec<TrainingRegistration>> {
        self.query_many_with_error(
            "SELECT id_user, registration_datetime, attended, attendance_time, id_training
FROM training_registration WHERE id_training = 1?",
            params![training_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn mark_training_attendance(
        &self,
        training_id: Uuid,
        user_id: Uuid,
        attended: bool,
    ) -> Result<()> {
        self.execute_with_error(
            "UPDATE training_registration SET attended = 1? WHERE training_id: 2?, user_id: 3?",
            params![attended, training_id.to_string(), user_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }
}
--- turso_db/src/tuition_repo/mod.rs ---
use async_trait::async_trait;
use entities::tuition::Tuition;
use libsql::params;
use serde::Deserialize;
use use_cases::tuition_service::err::{Error, Result};
use use_cases::tuition_service::repository_trait::TuitionRepository;
use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl TuitionRepository for TursoDb {
    async fn record_tuition_payment(&self, tuition: &Tuition) -> Result<()> {
        self.execute_with_error(
            "INSERT INTO tuition (
id_tuition, id_user, amount, payment_date, deleted
) VALUES (?1, ?2, ?3, ?4, ?5)",
            params![
                tuition.id_tuition.to_string(),
                tuition.id_user.to_string(),
                tuition.amount,
                tuition.payment_date.format("%Y-%m-%d %H:%M:%S").to_string(),
                0
            ],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn get_tuition_by_id(&self, id: Uuid) -> Result<Option<Tuition>> {
        self.query_one_with_error(
            "SELECT id_tuition, id_user, amount, payment_date 
FROM tuition 
WHERE id_tuition = ?1 AND deleted = 0",
            params![id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn list_tuition_payments_for_user(&self, user_id: Uuid) -> Result<Vec<Tuition>> {
        self.query_many_with_error(
            "SELECT id_tuition, id_user, amount, payment_date 
FROM tuition 
WHERE id_user = ?1 AND deleted = 0
ORDER BY payment_date DESC",
            params![user_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn list_all_tuition_payments(&self) -> Result<Vec<Tuition>> {
        self.query_many_with_error(
            "SELECT id_tuition, id_user, amount, payment_date 
FROM tuition 
WHERE deleted = 0",
            params![],
            Error::UnknownDatabaseError,
        )
        .await
    }

    async fn has_active_tuition(&self, user_id: Uuid) -> Result<bool> {
        #[derive(Deserialize)]
        struct Count {
            count: i64,
        }

        let count: Count = self
            .query_one_with_error(
                "SELECT COUNT(*) as count
FROM tuition 
WHERE id_user = ?1 
AND deleted = 0 
AND payment_date >= DATETIME('now', '-30 days')",
                params![user_id.to_string()],
                Error::UnknownDatabaseError,
            )
            .await?
            .unwrap_or(Count { count: 0 });

        Ok(count.count > 0)
    }
}

#[cfg(test)]
mod test {
    use std::future::Future;

    use super::*;
    use chrono::Utc;
    use entities::tuition::Tuition;
    use rstest::{fixture, rstest};
    use uuid::Uuid;

    #[fixture]
    async fn repository() -> TursoDb {
        let db = crate::TestDbBuilder::create()
            .await
            .apply_doc_types()
            .await
            .apply_user_roles()
            .await
            .build();

        let conn = db.get_connection().await.expect("Failed to get connection");
        conn.execute("DELETE FROM tuition", params![])
            .await
            .expect("Failed to clear tuition table");
        conn.execute("DELETE FROM person", params![])
            .await
            .expect("Failed to clear person table");

        db
    }

    #[rstest]
    #[tokio::test]
    async fn test_record_and_get_tuition(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let user_id = Uuid::new_v4();
        let tuition_id = Uuid::new_v4();

        // Create a test user to satisfy the foreign key constraint
        db.create_test_user(user_id)
            .await
            .expect("Failed to create test user");

        let tuition = Tuition {
            id_tuition: tuition_id,
            id_user: user_id,
            amount: 100.0,
            payment_date: Utc::now().naive_utc(),
        };

        // Record the tuition payment
        db.record_tuition_payment(&tuition)
            .await
            .expect("Failed to record tuition");

        // Retrieve and verify the tuition
        let retrieved_tuition = db
            .get_tuition_by_id(tuition_id)
            .await
            .expect("Failed to get tuition")
            .expect("Tuition not found");

        assert_eq!(tuition.id_tuition, retrieved_tuition.id_tuition);
    }

    #[rstest]
    #[tokio::test]
    async fn test_list_tuitions_for_user(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let user1_id = Uuid::new_v4();
        let user2_id = Uuid::new_v4();

        db.create_test_user(user1_id)
            .await
            .expect("Failed to create test user");
        db.create_test_user(user2_id)
            .await
            .expect("Failed to create test user");

        // Create 2 tuitions for user1
        for i in 0..2 {
            let tuition = Tuition {
                id_tuition: Uuid::new_v4(),
                id_user: user1_id,
                amount: 100.0 + i as f64,
                payment_date: Utc::now().naive_utc(),
            };

            db.record_tuition_payment(&tuition)
                .await
                .expect("Failed to record tuition");
        }

        // Create 1 tuition for user2
        let tuition = Tuition {
            id_tuition: Uuid::new_v4(),
            id_user: user2_id,
            amount: 200.0,
            payment_date: Utc::now().naive_utc(),
        };

        db.record_tuition_payment(&tuition)
            .await
            .expect("Failed to record tuition");

        let user1_tuitions = db
            .list_tuition_payments_for_user(user1_id)
            .await
            .expect("Failed to list tuitions");

        assert_eq!(user1_tuitions.len(), 2);
        assert_eq!(user1_tuitions[0].id_user, user1_id);
        assert_eq!(user1_tuitions[1].id_user, user1_id);

        // Test listing for user2
        let user2_tuitions = db
            .list_tuition_payments_for_user(user2_id)
            .await
            .expect("Failed to list tuitions");

        assert_eq!(user2_tuitions.len(), 1);
        assert_eq!(user2_tuitions[0].id_user, user2_id);
        assert_eq!(user2_tuitions[0].amount, 200.0);
    }

    #[rstest]
    #[tokio::test]
    async fn test_has_active_tuition(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;
        let user_id = Uuid::new_v4();

        db.create_test_user(user_id)
            .await
            .expect("Failed to create test user");

        // Initially no active tuition
        assert!(!db.has_active_tuition(user_id).await.unwrap());

        // Add a tuition
        let tuition = Tuition {
            id_tuition: Uuid::new_v4(),
            id_user: user_id,
            amount: 100.0,
            payment_date: Utc::now().naive_utc(),
        };

        db.record_tuition_payment(&tuition)
            .await
            .expect("Failed to record tuition");

        // Now has active tuition
        assert!(db.has_active_tuition(user_id).await.unwrap());

        // Delete the tuition
        db.execute_with_error(
            "UPDATE tuition SET deleted = 1 WHERE id_user = ?1",
            params![user_id.to_string()],
            Error::UnknownDatabaseError,
        )
        .await
        .expect("Failed to delete tuition");

        // Should no longer have active tuition
        assert!(!db.has_active_tuition(user_id).await.unwrap());
    }
}
--- turso_db/src/user_repo/mod.rs ---
use async_trait::async_trait;
use entities::user::{IdType, User};
use libsql::{de, params};
use use_cases::user_service::err::{Error, Result};
use use_cases::user_service::repository_trait::UserRepository;
use uuid::Uuid;

use crate::TursoDb;

#[async_trait]
impl UserRepository for TursoDb {
    async fn create_user(&self, user: &User) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "INSERT INTO person (
                id_user, first_name, last_name, birth_date, registration_date, 
                email, email_verified, phone_number, country_code, password, 
                identification_number, identification_type, user_rol
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13)",
            params![
                user.id_user.to_string(),
                user.first_name.to_string(),
                user.last_name.to_string(),
                user.birth_date.format("%Y-%m-%d").to_string(),
                user.registration_date
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                user.email.to_string(),
                user.email_verified as i32,
                user.phone_number.to_string(),
                user.country_code.to_string(),
                user.password.to_string(),
                user.identification_number.to_string(),
                user.identification_type.to_string(),
                user.user_rol.to_string(),
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn get_user_by_id(&self, id: Uuid) -> Result<Option<User>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("connection error: {err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_user, first_name, last_name, birth_date, registration_date, email,
email_verified, phone_number, country_code, password, identification_number, identification_type, user_rol FROM person WHERE id_user = ?1 AND deleted = 0",
                params![id.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        if let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let row = row_result;
            let user = de::from_row::<User>(&row)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            Ok(Some(user))
        } else {
            Ok(None)
        }
    }

    async fn get_user_id_by_email(&self, email: &str) -> Result<Option<Uuid>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_user FROM person 
                 WHERE email = ?1 AND deleted = 0",
                params![email],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        if let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let id_str: String = row_result
                .get(0)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

            let uuid = Uuid::parse_str(&id_str)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            Ok(Some(uuid))
        } else {
            Ok(None)
        }
    }

    async fn get_user_id_by_phone(&self, phone_number: &str) -> Result<Option<Uuid>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_user FROM person 
                 WHERE phone_number = ?1 AND deleted = 0",
                params![phone_number],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        if let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let id_str: String = row_result
                .get(0)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

            let uuid = Uuid::parse_str(&id_str)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            Ok(Some(uuid))
        } else {
            Ok(None)
        }
    }

    async fn get_user_id_by_identification(
        &self,
        identification_number: &str,
        identification_type: &IdType,
    ) -> Result<Option<Uuid>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_user FROM person 
                 WHERE identification_number = ?1 
AND identification_type = ?2 
AND deleted = 0",
                params![identification_number, identification_type.to_string()],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        if let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let id_str: String = row_result
                .get(0)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            let uuid = Uuid::parse_str(&id_str)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            Ok(Some(uuid))
        } else {
            Ok(None)
        }
    }

    async fn update_user(&self, user: &User) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "UPDATE person SET 
first_name = ?1, 
last_name = ?2, 
birth_date = ?3, 
registration_date = ?4, 
email = ?5, 
email_verified = ?6, 
phone_number = ?7, 
country_code = ?8, 
password = ?9, 
identification_number = ?10, 
identification_type = ?11, 
user_rol = ?12,
deleted = ?13
WHERE id_user = ?14",
            params![
                user.first_name.to_string(),
                user.last_name.to_string(),
                user.birth_date.format("%Y-%m-%d").to_string(),
                user.registration_date
                    .format("%Y-%m-%d %H:%M:%S")
                    .to_string(),
                user.email.to_string(),
                user.email_verified as i32,
                user.phone_number.to_string(),
                user.country_code.to_string(),
                user.password.to_string(),
                user.identification_number.to_string(),
                user.identification_type.to_string(),
                user.user_rol.to_string(),
                user.id_user.to_string(),
            ],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn delete_user(&self, id: Uuid) -> Result<()> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        conn.execute(
            "UPDATE person SET deleted = 1 WHERE id_user = ?1",
            params![id.to_string()],
        )
        .await
        .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        Ok(())
    }

    async fn list_users(&self) -> Result<Vec<User>> {
        let conn = self
            .get_connection()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut rows = conn
            .query(
                "SELECT id_user, first_name, last_name, birth_date, registration_date, email,
email_verified, phone_number, country_code, password, identification_number,
identification_type, user_rol 
FROM person 
WHERE deleted = 0",
                params![],
            )
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;

        let mut users = Vec::new();
        while let Some(row_result) = rows
            .next()
            .await
            .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?
        {
            let user = de::from_row::<User>(&row_result)
                .map_err(|err| Error::UnknownDatabaseError(format!("{err}")))?;
            users.push(user);
        }

        Ok(users)
    }
}

#[cfg(test)]
mod test {
    use std::{future::Future, process::Output};

    use entities::user::{IdType, User};
    use rstest::{fixture, rstest};
    use use_cases::user_service::repository_trait::UserRepository;
    use uuid::Uuid;

    use crate::{TestDbBuilder, TursoDb};

    #[fixture]
    async fn repository() -> TursoDb {
        let db = TestDbBuilder::create()
            .await
            .apply_doc_types()
            .await
            .apply_user_roles()
            .await
            .build();

        db
    }

    #[rstest]
    #[tokio::test]
    async fn test_create_user(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();

        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: "estebanmff@gmail.com".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        let user_db = db
            .get_user_by_id(user_id)
            .await
            .expect("Error getting user by id")
            .expect("User was not added");

        assert_eq!(user, user_db)
    }

    #[rstest]
    #[tokio::test]
    async fn test_get_user_by_id(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();

        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: "estebanmff@gmail.com".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        let user_db = db
            .get_user_by_id(user_id)
            .await
            .expect("Error getting user by id")
            .expect("User was not added");

        assert_eq!(user, user_db);

        let user_db = db
            .get_user_by_id(Uuid::new_v4())
            .await
            .expect("Error getting user by id");

        assert!(user_db.is_none());
    }

    #[rstest]
    #[tokio::test]
    async fn test_get_user_id_by_email(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();
        let email = "test_email@example.com".to_string();
        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: email.clone(),
            phone_number: "1234567890".to_string(),
            identification_number: "ID_EMAIL_1".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        let fetched_id = db
            .get_user_id_by_email(&email)
            .await
            .expect("Error fetching user id by email");
        assert_eq!(fetched_id, Some(user_id));
    }

    #[rstest]
    #[tokio::test]
    async fn test_get_user_id_by_phone(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();
        let phone_number = "555-1234".to_string();
        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: "test_phone@example.com".to_string(),
            phone_number: phone_number.clone(),
            identification_number: "ID_PHONE_1".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        let fetched_id = db
            .get_user_id_by_phone(&phone_number)
            .await
            .expect("Error fetching user id by phone");
        assert_eq!(fetched_id, Some(user_id));
    }

    #[rstest]
    #[tokio::test]
    async fn test_get_user_id_by_identification(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();
        let identification_number = "ID-IDENT-1234".to_string();
        let identification_type = IdType::default(); // default is CC, for example
        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: "test_ident@example.com".to_string(),
            identification_number: identification_number.clone(),
            identification_type,
            phone_number: "9876543210".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        let fetched_id = db
            .get_user_id_by_identification(&identification_number, &IdType::default())
            .await
            .expect("Error fetching user id by identification");
        assert_eq!(fetched_id, Some(user_id));
    }

    #[rstest]
    #[tokio::test]
    async fn test_update_user(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();
        let db = repository.await;

        let mut user = User {
            id_user: user_id,
            email: "original@example.com".to_string(),
            first_name: "Original".to_string(),
            phone_number: "0001112222".to_string(),
            identification_number: "ID_UPDATE_1".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        // Update some fields.
        user.first_name = "Updated".to_string();
        user.email = "updated@example.com".to_string();

        db.update_user(&user).await.expect("Error updating user");

        let updated_user = db
            .get_user_by_id(user_id)
            .await
            .expect("Error fetching updated user")
            .expect("User not found after update");

        assert_ne!(user, updated_user);
    }

    #[rstest]
    #[tokio::test]
    async fn test_delete_user(repository: impl Future<Output = TursoDb>) {
        let user_id = Uuid::new_v4();
        let db = repository.await;

        let user = User {
            id_user: user_id,
            email: "delete_me@example.com".to_string(),
            ..User::default()
        };

        db.create_user(&user).await.expect("Error creating user");

        db.delete_user(user_id).await.expect("Error deleting user");

        let deleted_user = db
            .get_user_by_id(user_id)
            .await
            .expect("Error fetching user after delete");
        assert!(deleted_user.is_none());
    }

    #[rstest]
    #[tokio::test]
    async fn test_list_users(repository: impl Future<Output = TursoDb>) {
        let db = repository.await;

        // Get the initial list of users.
        let initial_users = db.list_users().await.expect("Error listing initial users");
        let initial_count = initial_users.len();

        // Create two users.
        let user1 = User {
            id_user: Uuid::new_v4(),
            email: "list1@example.com".to_string(),
            phone_number: "111111".to_string(),
            identification_number: "ID_LIST_1".to_string(),
            ..User::default()
        };
        let user2 = User {
            id_user: Uuid::new_v4(),
            email: "list2@example.com".to_string(),
            phone_number: "222222".to_string(),
            identification_number: "ID_LIST_2".to_string(),
            ..User::default()
        };

        db.create_user(&user1).await.expect("Error creating user1");
        db.create_user(&user2).await.expect("Error creating user2");

        let users_after_insert = db
            .list_users()
            .await
            .expect("Error listing users after insert");
        assert_eq!(users_after_insert.len(), initial_count + 2);

        // Delete one user.
        db.delete_user(user1.id_user)
            .await
            .expect("Error deleting user1");

        let users_after_delete = db
            .list_users()
            .await
            .expect("Error listing users after deletion");
        assert_eq!(users_after_delete.len(), initial_count + 1);

        // Ensure that user1 is no longer listed.
        for user in users_after_delete {
            assert_ne!(user.id_user, user1.id_user);
        }
    }
}
--- use_cases/src/category_service/err.rs ---
use thiserror::Error;

use crate::user_service;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Database error: {0}")]
    UnknownDatabaseError(String),

    #[error("Category not found")]
    CategoryNotFound,

    #[error("Category already exists")]
    CategoryAlreadyExists,

    #[error("Invalid age range: min_age must be less than max_age")]
    InvalidAgeRange,

    #[error("Category name is required")]
    MissingName,

    #[error("Category requirement not found")]
    RequirementNotFound,

    #[error("User already has this category")]
    UserAlreadyHasCategory,

    #[error("User does not meet category requirements")]
    UserDoesNotMeetRequirements,

    #[error("Level not found")]
    LevelNotFound,

    #[error("Invalid age")]
    InvalidUserAge,

    #[error("Presequisite category level, is less than the required")]
    InvalidRequirementLevel,

    #[error("Error in user service")]
    UserServiceError(#[from] user_service::err::Error),
}
--- use_cases/src/category_service/mod.rs ---
use chrono::Utc;
use entities::{
    category::{Category, CategoryCreation, CategoryRequirement, LevelName},
    user::UserCategory,
};
use err::{Error, Result};
use repository_trait::{CategoryRepository, CategoryRequirementRepository, UserCategoryRepository};
use std::sync::Arc;
use uuid::Uuid;

use crate::user_service::UserService;

pub mod err;
pub mod repository_trait;

#[derive(Clone)]
pub struct CategoryService {
    category_repo: Arc<dyn CategoryRepository>,
    requirement_repo: Arc<dyn CategoryRequirementRepository>,
    user_category_repo: Arc<dyn UserCategoryRepository>,
    user_service: UserService,
}

impl CategoryService {
    pub fn new(
        category_repo: Arc<dyn CategoryRepository>,
        requirement_repo: Arc<dyn CategoryRequirementRepository>,
        user_category_repo: Arc<dyn UserCategoryRepository>,
        user_repo: UserService,
    ) -> Self {
        Self {
            category_repo,
            requirement_repo,
            user_category_repo,
            user_service: user_repo,
        }
    }

    //  delete_category
    pub async fn delete_category(&self, id: Uuid) -> Result<()> {
        self.category_repo.delete_category(id).await?;
        Ok(())
    }

    pub async fn update_category(&self, category: &Category) -> Result<()> {
        // Validate category exists
        if self
            .category_repo
            .get_category_by_id(category.id_category)
            .await?
            .is_none()
        {
            return Err(Error::CategoryNotFound);
        }

        // Validate category name
        if category.name.trim().is_empty() {
            return Err(Error::MissingName);
        }

        // Validate age range
        if category.min_age >= category.max_age {
            return Err(Error::InvalidAgeRange);
        }

        self.category_repo.update_category(category).await?;
        Ok(())
    }

    pub async fn get_category_by_id(&self, id: Uuid) -> Result<Category> {
        self.category_repo
            .get_category_by_id(id)
            .await?
            .ok_or(Error::CategoryNotFound)
    }

    pub async fn get_all_categories(&self) -> Result<Vec<Category>> {
        self.category_repo.list_categories().await
    }

    pub async fn add_category(&self, category_creation: CategoryCreation) -> Result<()> {
        if self
            .category_repo
            .get_category_by_name(&category_creation.name)
            .await?
            .is_some()
        {
            return Err(Error::CategoryAlreadyExists);
        }

        let category = category_creation.to_category(Uuid::new_v4());

        self.category_repo.create_category(&category).await?;

        Ok(())
    }

    pub async fn add_category_requirement(&self, category_req: &CategoryRequirement) -> Result<()> {
        self.requirement_repo
            .create_category_requirement(category_req)
            .await
    }

    pub async fn get_category_requirements(
        &self,
        category_id: Uuid,
    ) -> Result<Vec<CategoryRequirement>> {
        self.requirement_repo
            .get_category_requirements(category_id)
            .await
    }

    pub async fn get_user_category(
        &self,
        user_id: Uuid,
        category_id: Uuid,
    ) -> Result<Option<UserCategory>> {
        self.user_category_repo
            .get_user_category(user_id, category_id)
            .await
    }

    pub async fn user_has_category(&self, user_id: Uuid, category_id: Uuid) -> Result<bool> {
        self.user_category_repo
            .user_has_category(user_id, category_id)
            .await
    }

    pub async fn get_user_categories(&self, user_id: Uuid) -> Result<Vec<UserCategory>> {
        self.user_category_repo.get_user_categories(user_id).await
    }

    pub async fn add_user_to_category(&self, user_id: Uuid, category_id: Uuid) -> Result<()> {
        if self.user_has_category(user_id, category_id).await? {
            return Err(Error::UserAlreadyHasCategory);
        }

        let category = self.get_category_by_id(category_id).await?;

        let user = self.user_service.get_user_by_id(user_id).await?;

        let current_date = Utc::now().naive_utc().date();
        let birth_date = user.birth_date;
        let user_age = current_date.years_since(birth_date).unwrap_or(0);

        if (category.min_age as u32) > user_age || (category.max_age as u32) < user_age {
            return Err(Error::InvalidUserAge);
        }

        let requirements = self.get_category_requirements(category_id).await?;

        for requirement in requirements {
            if let Some(user_category) = self
                .get_user_category(user_id, requirement.id_category)
                .await?
            {
                if user_category.user_level < requirement.required_level {
                    return Err(Error::InvalidRequirementLevel);
                }
            } else {
                return Err(Error::UserDoesNotMeetRequirements);
            }
        }

        let user_category = UserCategory {
            id_user: user_id,
            id_category: category_id,
            user_level: LevelName::BEGGINER,
        };

        self.user_category_repo
            .create_user_category(&user_category)
            .await?;

        Ok(())
    }

    // get user categories it is elegible to
    //pub async fn get_elegible_categories(
    //    &self,
    //    category_id: Uuid,
    //    user_id: _,
    //) -> Result<Vec<Category>> {
    //    todo!()
    //}
}
--- use_cases/src/category_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::{
    category::{Category, CategoryRequirement, Level},
    user::UserCategory,
};
use uuid::Uuid;

#[async_trait]
pub trait CategoryRepository: Send + Sync {
    async fn create_category(&self, category: &Category) -> Result<()>;
    async fn get_category_by_id(&self, id: Uuid) -> Result<Option<Category>>;
    async fn update_category(&self, category: &Category) -> Result<()>;
    async fn delete_category(&self, id: Uuid) -> Result<()>; // Soft delete
    async fn list_categories(&self) -> Result<Vec<Category>>;
    async fn get_category_by_name(&self, name: &str) -> Result<Option<Category>>;
}

#[async_trait]
pub trait LevelRepository: Send + Sync {
    async fn create_level(&self, level: &Level) -> Result<()>;
    async fn get_level_by_id(&self, id: Uuid) -> Result<Option<Level>>;
    async fn list_levels(&self) -> Result<Vec<Level>>;
}

#[async_trait]
pub trait CategoryRequirementRepository: Send + Sync {
    async fn create_category_requirement(&self, requirement: &CategoryRequirement) -> Result<()>;
    async fn get_category_requirements(
        &self,
        category_id: Uuid,
    ) -> Result<Vec<CategoryRequirement>>;
}

#[async_trait]
pub trait UserCategoryRepository: Send + Sync {
    async fn get_user_category(
        &self,
        id_user: Uuid,
        id_category: Uuid,
    ) -> Result<Option<UserCategory>>;

    async fn user_has_category(&self, id_user: Uuid, id_category: Uuid) -> Result<bool>;

    async fn create_user_category(&self, user_category: &UserCategory) -> Result<()>;

    async fn get_user_categories(&self, user_id: Uuid) -> Result<Vec<UserCategory>>;
}
--- use_cases/src/lib.rs ---
pub mod category_service;
pub mod request_service;
pub mod tournament_service;
pub mod training_service;
pub mod tuition_service;
pub mod user_service;
--- use_cases/src/request_service/err.rs ---
use thiserror::Error;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Database error: {0}")]
    UnknownDatabaseError(String),
    #[error("Request not found")]
    RequestNotFound,
    #[error("Request already completed")]
    RequestAlreadyCompleted,
    #[error("Cannot approve/reject your own request")]
    SelfApprovalNotAllowed,
    #[error("Invalid approver ID")]
    InvalidApprover,
}
--- use_cases/src/request_service/mod.rs ---
pub mod err;
pub mod repository_trait;

use self::err::{Error, Result};
use entities::request::Request;
use repository_trait::RequestRepository;
use std::sync::Arc;
use uuid::Uuid;

#[derive(Clone)]
pub struct RequestService {
    request_repo: Arc<dyn RequestRepository + Send + Sync>,
}

impl RequestService {
    pub fn new(request_repo: Arc<dyn RequestRepository + Send + Sync>) -> Self {
        Self { request_repo }
    }

    pub async fn create_request(
        &self,
        requester_id: Uuid,
        requested_command: String,
        justification: String,
    ) -> Result<()> {
        let request = Request {
            request_id: Uuid::new_v4(),
            requester_id,
            requested_command,
            justification,
            approved: None,
            approver_id: None,
        };

        self.request_repo.create_request(&request).await
    }

    pub async fn complete_request(
        &self,
        request_id: Uuid,
        approver_id: Uuid,
        approved: bool,
    ) -> Result<()> {
        let mut request = self
            .request_repo
            .get_request_by_id(request_id)
            .await?
            .ok_or(Error::RequestNotFound)?;

        if request.requester_id == approver_id {
            return Err(Error::SelfApprovalNotAllowed);
        }

        if request.approved.is_some() {
            return Err(Error::RequestAlreadyCompleted);
        }

        request.approved = Some(approved);
        request.approver_id = Some(approver_id);

        self.request_repo.update_request(&request).await
    }

    pub async fn list_requests(&self) -> Result<Vec<Request>> {
        self.request_repo.list_requests().await
    }

    pub async fn list_user_requests(&self, user_id: Uuid) -> Result<Vec<Request>> {
        self.request_repo.list_requests_by_user(user_id).await
    }

    pub async fn get_request_by_id(&self, id: Uuid) -> Result<Option<Request>> {
        self.request_repo.get_request_by_id(id).await
    }
}
--- use_cases/src/request_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::request::Request;
use uuid::Uuid;

#[async_trait]
pub trait RequestRepository: Send + Sync {
    async fn create_request(&self, request: &Request) -> Result<()>;
    async fn get_request_by_id(&self, id: Uuid) -> Result<Option<Request>>;
    async fn update_request(&self, request: &Request) -> Result<()>;
    async fn list_requests(&self) -> Result<Vec<Request>>;
    async fn list_requests_by_user(&self, user_id: Uuid) -> Result<Vec<Request>>;
}
--- use_cases/src/tournament_service/err.rs ---
use thiserror::Error;

use crate::category_service;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Database error: {0}")]
    UnknownDatabaseError(String),
    #[error("Tournament not found")]
    TournamentNotFound,
    #[error("User not registered for tournament")]
    UserNotRegistered,
    #[error("User already registered")]
    UserAlreadyRegistered,
    #[error("Invalid tournament dates")]
    InvalidDates,
    #[error("Invalid category")]
    InvalidCategory,
    #[error("Invalid position, the position must be positive")]
    NegativePosition,
    #[error("Invalid position, already taken")]
    PositionAlreadyTaken,
    #[error("User did not attend tournament")]
    UserDidNotAttend,
    #[error("User does not meet tournament category requirements")]
    UserDoesNotMeetCategoryRequirements,
    #[error("Category Service Error")]
    CategoryServiceError(#[from] category_service::err::Error),
}
--- use_cases/src/tournament_service/mod.rs ---
pub mod err;
pub mod repository_trait;

use crate::category_service::CategoryService;

use self::err::{Error, Result};
use entities::tournament::{
    Tournament, TournamentAttendance, TournamentCreation, TournamentRegistration,
};
use repository_trait::{
    TournamentAttendanceRepository, TournamentRegistrationRepository, TournamentRepository,
};
use std::sync::Arc;
use uuid::Uuid;

#[derive(Clone)]
pub struct TournamentService {
    tournament_repo: Arc<dyn TournamentRepository + Send + Sync>,
    registration_repo: Arc<dyn TournamentRegistrationRepository + Send + Sync>,
    attendance_repo: Arc<dyn TournamentAttendanceRepository + Send + Sync>,
    category_service: CategoryService,
}

impl TournamentService {
    pub fn new(
        tournament_repo: Arc<dyn TournamentRepository + Send + Sync>,
        registration_repo: Arc<dyn TournamentRegistrationRepository + Send + Sync>,
        attendance_repo: Arc<dyn TournamentAttendanceRepository + Send + Sync>,
        category_service: CategoryService,
    ) -> Self {
        Self {
            tournament_repo,
            registration_repo,
            attendance_repo,
            category_service,
        }
    }

    pub async fn create_tournament(&self, tournament: TournamentCreation) -> Result<()> {
        if tournament.start_datetime >= tournament.end_datetime {
            return Err(Error::InvalidDates);
        }

        self.tournament_repo
            .create_tournament(&tournament.to_tournament(Uuid::new_v4()))
            .await?;

        Ok(())
    }

    pub async fn get_tournament(&self, id: Uuid) -> Result<Tournament> {
        self.tournament_repo
            .get_tournament_by_id(id)
            .await?
            .ok_or(Error::TournamentNotFound)
    }

    pub async fn update_tournament(&self, tournament: Tournament) -> Result<()> {
        if tournament.start_datetime >= tournament.end_datetime {
            return Err(Error::InvalidDates);
        }

        if self
            .tournament_repo
            .get_tournament_by_id(tournament.id_tournament)
            .await?
            .is_none()
        {
            return Err(Error::TournamentNotFound);
        }

        self.tournament_repo
            .update_tournament(&Tournament {
                id_tournament: tournament.id_tournament,
                name: tournament.name,
                id_category: tournament.id_category,
                start_datetime: tournament.start_datetime,
                end_datetime: tournament.end_datetime,
            })
            .await?;

        Ok(())
    }

    pub async fn delete_tournament(&self, id: Uuid) -> Result<()> {
        if self
            .tournament_repo
            .get_tournament_by_id(id)
            .await?
            .is_none()
        {
            return Err(Error::TournamentNotFound);
        }

        self.tournament_repo.delete_tournament(id).await?;

        Ok(())
    }

    pub async fn list_tournaments(&self) -> Result<Vec<Tournament>> {
        let tournaments = self.tournament_repo.list_tournaments().await?;

        Ok(tournaments)
    }

    pub async fn register_user(&self, registration: TournamentRegistration) -> Result<()> {
        let tournament = self
            .tournament_repo
            .get_tournament_by_id(registration.id_tournament)
            .await?
            .ok_or(Error::TournamentNotFound)?;

        if !self
            .category_service
            .user_has_category(registration.id_user, tournament.id_category)
            .await?
        {
            return Err(Error::UserDoesNotMeetCategoryRequirements);
        }

        let registrations = self
            .registration_repo
            .get_tournament_registrations(registration.id_tournament)
            .await?;
        if registrations
            .iter()
            .any(|r| r.id_user == registration.id_user)
        {
            return Err(Error::UserAlreadyRegistered);
        }

        self.registration_repo
            .register_user_for_tournament(&TournamentRegistration {
                id_tournament: registration.id_tournament,
                id_user: registration.id_user,
                registration_datetime: registration.registration_datetime,
            })
            .await?;

        Ok(())
    }

    pub async fn record_attendance(&self, attendance: TournamentAttendance) -> Result<()> {
        if self
            .tournament_repo
            .get_tournament_by_id(attendance.id_tournament)
            .await?
            .is_none()
        {
            return Err(Error::TournamentNotFound);
        }

        let registrations = self
            .registration_repo
            .get_tournament_registrations(attendance.id_tournament)
            .await?;
        if !registrations
            .iter()
            .any(|r| r.id_user == attendance.id_user)
        {
            return Err(Error::UserNotRegistered);
        }

        self.attendance_repo
            .record_tournament_attendance(&TournamentAttendance {
                id_tournament: attendance.id_tournament,
                id_user: attendance.id_user,
                attendance_datetime: attendance.attendance_datetime,
                position: attendance.position,
            })
            .await?;

        Ok(())
    }

    pub async fn update_position(
        &self,
        tournament_id: Uuid,
        user_id: Uuid,
        position: i32,
    ) -> Result<()> {
        if self
            .tournament_repo
            .get_tournament_by_id(tournament_id)
            .await?
            .is_none()
        {
            return Err(Error::TournamentNotFound);
        }

        let attendance = self
            .attendance_repo
            .get_tournament_attendance(tournament_id)
            .await?;
        if !attendance.iter().any(|a| a.id_user == user_id) {
            return Err(Error::UserDidNotAttend);
        }

        if attendance.iter().any(|a| a.position == position) {
            return Err(Error::PositionAlreadyTaken);
        }

        if position < 1 {
            return Err(Error::NegativePosition);
        }

        self.attendance_repo
            .update_tournament_position(tournament_id, user_id, position)
            .await?;

        Ok(())
    }

    pub async fn get_eligible_tournaments(&self, user_id: Uuid) -> Result<Vec<Tournament>> {
        let all_tournaments = self.tournament_repo.list_tournaments().await?;

        let user_categories = self.category_service.get_user_categories(user_id).await?;
        let user_category_ids: Vec<Uuid> = user_categories
            .into_iter()
            .map(|uc| uc.id_category)
            .collect();

        let eligible_tournaments = all_tournaments
            .into_iter()
            .filter(|t| user_category_ids.contains(&t.id_category))
            .collect();

        Ok(eligible_tournaments)
    }
}
--- use_cases/src/tournament_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::tournament::{Tournament, TournamentAttendance, TournamentRegistration};
use uuid::Uuid;

/// Trait defining tournament-related operations
#[async_trait]
pub trait TournamentRepository: Send + Sync {
    async fn create_tournament(&self, tournament: &Tournament) -> Result<()>;
    async fn get_tournament_by_id(&self, id: Uuid) -> Result<Option<Tournament>>;
    async fn update_tournament(&self, tournament: &Tournament) -> Result<()>;
    async fn delete_tournament(&self, id: Uuid) -> Result<()>; // Soft delete
    async fn list_tournaments(&self) -> Result<Vec<Tournament>>;
}

#[async_trait]
pub trait TournamentRegistrationRepository: Send + Sync {
    async fn register_user_for_tournament(
        &self,
        registration: &TournamentRegistration,
    ) -> Result<()>;
    async fn get_tournament_registrations(
        &self,
        tournament_id: Uuid,
    ) -> Result<Vec<TournamentRegistration>>;
}

#[async_trait]
pub trait TournamentAttendanceRepository: Send + Sync {
    async fn record_tournament_attendance(&self, attendance: &TournamentAttendance) -> Result<()>;
    async fn get_tournament_attendance(
        &self,
        tournament_id: Uuid,
    ) -> Result<Vec<TournamentAttendance>>;
    async fn update_tournament_position(
        &self,
        tournament_id: Uuid,
        user_id: Uuid,
        position: i32,
    ) -> Result<()>;
}
--- use_cases/src/training_service/err.rs ---
use thiserror::Error;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Unknown error in the database: {0}")]
    UnknownDatabaseError(String),

    #[error("Training not found")]
    TrainingNotFound,

    #[error("User already registered for this training")]
    UserAlreadyRegistered,

    #[error("User does not meet category requirements")]
    UserDoesNotMeetCategoryRequirements,

    #[error("Invalid dates: start date must be before end date")]
    InvalidDates,

    #[error("User not registered for this training")]
    UserNotRegistered,

    #[error("Training registration not found")]
    RegistrationNotFound,

    #[error("Error in category service")]
    CategoryServiceError(#[from] crate::category_service::err::Error),
}
--- use_cases/src/training_service/mod.rs ---
pub mod err;
pub mod repository_trait;

use err::{Error, Result};
use repository_trait::{TrainingRegistrationRepository, TrainingRepository};

use crate::category_service::CategoryService;
use entities::training::{Training, TrainingCreation, TrainingRegistration};
use std::sync::Arc;
use uuid::Uuid;

#[derive(Clone)]
pub struct TrainingService {
    training_repo: Arc<dyn TrainingRepository + Send + Sync>,
    registration_repo: Arc<dyn TrainingRegistrationRepository + Send + Sync>,
    category_service: CategoryService,
}

impl TrainingService {
    pub fn new(
        training_repo: Arc<dyn TrainingRepository + Send + Sync>,
        registration_repo: Arc<dyn TrainingRegistrationRepository + Send + Sync>,
        category_service: CategoryService,
    ) -> Self {
        Self {
            training_repo,
            registration_repo,
            category_service,
        }
    }

    pub async fn create_training(&self, training_creation: &TrainingCreation) -> Result<()> {
        if training_creation.start_datetime >= training_creation.end_datetime {
            return Err(Error::InvalidDates);
        }

        let training = training_creation.to_training_cloned(Uuid::new_v4());

        self.training_repo.create_training(&training).await
    }

    pub async fn get_training(&self, id: Uuid) -> Result<Training> {
        self.training_repo
            .get_training_by_id(id)
            .await?
            .ok_or(Error::TrainingNotFound)
    }

    pub async fn update_training(&self, training: &Training) -> Result<()> {
        if training.start_datetime >= training.end_datetime {
            return Err(Error::InvalidDates);
        }

        if self
            .training_repo
            .get_training_by_id(training.id_training)
            .await?
            .is_none()
        {
            return Err(Error::TrainingNotFound);
        }

        self.training_repo.update_training(training).await
    }

    pub async fn delete_training(&self, id: Uuid) -> Result<()> {
        if self.training_repo.get_training_by_id(id).await?.is_none() {
            return Err(Error::TrainingNotFound);
        }

        self.training_repo.delete_training(id).await
    }

    pub async fn list_trainings(&self) -> Result<Vec<Training>> {
        self.training_repo.list_trainings().await
    }

    pub async fn register_user(&self, registration: TrainingRegistration) -> Result<()> {
        let training = self
            .training_repo
            .get_training_by_id(registration.id_training)
            .await?
            .ok_or(Error::TrainingNotFound)?;

        // Check if user has the required category
        if !self
            .category_service
            .user_has_category(registration.id_user, training.id_category)
            .await?
        {
            return Err(Error::UserDoesNotMeetCategoryRequirements);
        }

        // Check if user is already registered
        let registrations = self
            .registration_repo
            .get_training_registrations(registration.id_training)
            .await?;
        if registrations
            .iter()
            .any(|r| r.id_user == registration.id_user)
        {
            return Err(Error::UserAlreadyRegistered);
        }

        self.registration_repo
            .register_user_for_training(&registration)
            .await
    }

    pub async fn mark_attendance(
        &self,
        training_id: Uuid,
        user_id: Uuid,
        attended: bool,
    ) -> Result<()> {
        // Check if training exists
        if self
            .training_repo
            .get_training_by_id(training_id)
            .await?
            .is_none()
        {
            return Err(Error::TrainingNotFound);
        }

        // Check if user is registered
        let registrations = self
            .registration_repo
            .get_training_registrations(training_id)
            .await?;
        if !registrations.iter().any(|r| r.id_user == user_id) {
            return Err(Error::UserNotRegistered);
        }

        self.registration_repo
            .mark_training_attendance(training_id, user_id, attended)
            .await
    }

    pub async fn get_eligible_trainings(&self, user_id: Uuid) -> Result<Vec<Training>> {
        let all_trainings = self.training_repo.list_trainings().await?;

        let user_categories = self.category_service.get_user_categories(user_id).await?;
        let user_category_ids: Vec<Uuid> = user_categories
            .into_iter()
            .map(|uc| uc.id_category)
            .collect();

        let eligible_trainings = all_trainings
            .into_iter()
            .filter(|training| user_category_ids.contains(&training.id_category))
            .collect();

        Ok(eligible_trainings)
    }
}
--- use_cases/src/training_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::training::{Training, TrainingRegistration};
use uuid::Uuid;

#[async_trait]
pub trait TrainingRepository {
    async fn create_training(&self, training: &Training) -> Result<()>;
    async fn get_training_by_id(&self, id: Uuid) -> Result<Option<Training>>;
    async fn update_training(&self, training: &Training) -> Result<()>;
    async fn delete_training(&self, id: Uuid) -> Result<()>; // Soft delete
    async fn list_trainings(&self) -> Result<Vec<Training>>;
}

#[async_trait]
pub trait TrainingRegistrationRepository {
    async fn register_user_for_training(&self, registration: &TrainingRegistration) -> Result<()>;

    async fn get_training_registrations(
        &self,
        training_id: Uuid,
    ) -> Result<Vec<TrainingRegistration>>;

    async fn mark_training_attendance(
        &self,
        training_id: Uuid,
        user_id: Uuid,
        attended: bool,
    ) -> Result<()>;
}
--- use_cases/src/tuition_service/err.rs ---
use thiserror::Error;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Database error: {0}")]
    UnknownDatabaseError(String),
    #[error("Active tuition already exists")]
    ActiveTuitionExists,
    #[error("Invalid payment amount")]
    InvalidAmount,
    #[error("Tuition not found")]
    TuitionNotFound,
}
--- use_cases/src/tuition_service/mod.rs ---
pub mod err;
pub mod repository_trait;
mod tests;

use self::err::{Error, Result};
use chrono::Utc;
use entities::tuition::Tuition;
use repository_trait::TuitionRepository;
use std::sync::Arc;
use uuid::Uuid;

#[derive(Clone)]
pub struct TuitionService {
    tuition_repo: Arc<dyn TuitionRepository + Send + Sync>,
}

impl TuitionService {
    pub fn new(tuition_repo: Arc<dyn TuitionRepository + Send + Sync>) -> Self {
        Self { tuition_repo }
    }

    pub async fn pay_tuition(&self, user_id: Uuid, amount: f64) -> Result<()> {
        if amount <= 0.0 {
            return Err(Error::InvalidAmount);
        }

        if self.tuition_repo.has_active_tuition(user_id).await? {
            return Err(Error::ActiveTuitionExists);
        }

        let new_tuition = Tuition {
            id_tuition: Uuid::new_v4(),
            id_user: user_id,
            amount,
            payment_date: Utc::now().naive_utc(),
        };

        self.tuition_repo.record_tuition_payment(&new_tuition).await
    }

    pub async fn has_active_tuition(&self, user_id: Uuid) -> Result<bool> {
        self.tuition_repo.has_active_tuition(user_id).await
    }

    pub async fn get_user_tuitions(&self, user_id: Uuid) -> Result<Vec<Tuition>> {
        self.tuition_repo
            .list_tuition_payments_for_user(user_id)
            .await
    }

    pub async fn get_all_tuitions(&self) -> Result<Vec<Tuition>> {
        self.tuition_repo.list_all_tuition_payments().await
    }
}
--- use_cases/src/tuition_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::tuition::Tuition;
use uuid::Uuid;

#[async_trait]
pub trait TuitionRepository: Send + Sync {
    async fn record_tuition_payment(&self, tuition: &Tuition) -> Result<()>;
    async fn get_tuition_by_id(&self, id: Uuid) -> Result<Option<Tuition>>;
    async fn list_tuition_payments_for_user(&self, user_id: Uuid) -> Result<Vec<Tuition>>;
    async fn list_all_tuition_payments(&self) -> Result<Vec<Tuition>>;
    async fn has_active_tuition(&self, user_id: Uuid) -> Result<bool>;
}
--- use_cases/src/tuition_service/tests.rs ---

--- use_cases/src/user_service/err.rs ---
use thiserror::Error;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Unknow error in the database: {0}")]
    UnknownDatabaseError(String),
    #[error("User do not exists")]
    UserIdDontExist,
    #[error("Error hashing")]
    ErrorHashing(String),
    #[error("Error verifying hash")]
    ErrorVerificationHash(String),
    #[error("Error in password")]
    InvalidPassword,
    #[error("Email already exists")]
    EmailAlreadyExists,
    #[error("Phone number already exists")]
    PhoneAlreadyExists,
    #[error("Document already exists")]
    DocumentAlreadyExists,
    #[error("Invalid identifier")]
    InvalidIdentifier,
}
--- use_cases/src/user_service/hasher_trait.rs ---
use super::err::Result;

pub trait PasswordHasher: Send + Sync {
    fn hash(&self, content: &str) -> Result<String>;

    fn verify(&self, original: &str, hashed: &str) -> Result<bool>;
}
--- use_cases/src/user_service/mod.rs ---
use std::sync::Arc;

use chrono::Utc;
use entities::user::{self, URol, UserCreation, UserInfo, UserLogInInfo};
use hasher_trait::PasswordHasher;
use repository_trait::UserRepository;

pub mod err;
pub mod hasher_trait;
pub mod repository_trait;
mod unique_identifier;

use err::{Error, Result};
use unique_identifier::{EmailIdentifier, Identifier, PhoneIdentifier};
use uuid::Uuid;

#[derive(Clone)]
pub struct UserService {
    user_repo: Arc<dyn UserRepository>,
    password_hasher: Arc<dyn PasswordHasher>,
}

#[derive(Clone, Debug)]
pub struct LogInResponse {
    pub user_id: Uuid,
    pub user_rol: URol,
}

impl UserService {
    pub fn new(
        user_repo: Arc<dyn UserRepository>,
        password_hasher: Arc<dyn PasswordHasher>,
    ) -> Self {
        Self {
            user_repo,
            password_hasher,
        }
    }

    pub async fn register_user(&self, user_creation: UserCreation) -> Result<()> {
        let email = user_creation.email.clone();
        let phone = user_creation.phone_number.clone();
        let identification_number = user_creation.identification_number.clone();
        let identification_type = user_creation.identification_type.clone();

        let mut user =
            user_creation.to_user(Uuid::new_v4(), Utc::now().naive_utc(), false, URol::USER);

        if self.user_repo.get_user_id_by_email(&email).await?.is_some() {
            return Err(Error::EmailAlreadyExists);
        } else if self.user_repo.get_user_id_by_phone(&phone).await?.is_some() {
            return Err(Error::PhoneAlreadyExists);
        } else if self
            .user_repo
            .get_user_id_by_identification(&identification_number, &identification_type)
            .await?
            .is_some()
        {
            return Err(Error::DocumentAlreadyExists);
        }

        user.password = self.password_hasher.hash(&user.password)?;

        self.user_repo.create_user(&user).await?;

        Ok(())
    }

    pub async fn get_all_users(&self) -> Result<Vec<UserInfo>> {
        let users = self.user_repo.list_users().await?;

        let users_info = users.into_iter().map(UserInfo::from).collect();

        Ok(users_info)
    }

    pub async fn get_user_by_id(&self, user_id: Uuid) -> Result<UserInfo> {
        let user = self.user_repo.get_user_by_id(user_id).await?;

        match user {
            Some(user) => Ok(UserInfo::from(user)),
            None => Err(Error::UserIdDontExist),
        }
    }

    pub async fn update_user(&self, user_id: Uuid, mut user_update: UserCreation) -> Result<()> {
        // Check if user exists
        if self.user_repo.get_user_by_id(user_id).await?.is_none() {
            return Err(Error::UserIdDontExist);
        }

        let current_user = self.user_repo.get_user_by_id(user_id).await?.unwrap();

        // If password is being updated, hash it
        if !user_update.password.is_empty() {
            user_update.password = self.password_hasher.hash(&user_update.password)?;
        } else {
            user_update.password = current_user.password;
        }

        let user_update = user_update.to_user(
            current_user.id_user,
            current_user.registration_date,
            current_user.email_verified,
            current_user.user_rol,
        );

        self.user_repo.update_user(&user_update).await?;

        Ok(())
    }

    pub async fn log_in_user(&self, user_log_in_info: &UserLogInInfo) -> Result<LogInResponse> {
        let identifier = &user_log_in_info.identifier;

        let email_identifier: Arc<dyn Identifier> =
            Arc::new(EmailIdentifier::new(self.user_repo.clone(), None));

        let phone_identifier: Arc<dyn Identifier> = Arc::new(PhoneIdentifier::new(
            self.user_repo.clone(),
            Some(email_identifier),
        ));

        let user_id = phone_identifier.identify(identifier).await?;

        let user_info = match self.user_repo.get_user_by_id(user_id).await? {
            Some(user_info) => user_info,
            None => return Err(Error::UserIdDontExist),
        };

        let is_valid = self
            .password_hasher
            .verify(&user_log_in_info.password, &user_info.password)?;

        if !is_valid {
            return Err(Error::InvalidPassword);
        }

        Ok(LogInResponse {
            user_id,
            user_rol: user_info.user_rol,
        })
    }
}
--- use_cases/src/user_service/repository_trait.rs ---
use super::err::Result;
use async_trait::async_trait;
use entities::user::*;
use uuid::Uuid;

#[async_trait]
pub trait UserRepository: Sync + Send {
    async fn create_user(&self, user: &User) -> Result<()>;
    async fn get_user_by_id(&self, id: Uuid) -> Result<Option<User>>;

    async fn get_user_id_by_email(&self, email: &str) -> Result<Option<Uuid>>;
    async fn get_user_id_by_phone(&self, phone_number: &str) -> Result<Option<Uuid>>;
    async fn get_user_id_by_identification(
        &self,
        identification_number: &str,
        identification_type: &IdType,
    ) -> Result<Option<Uuid>>;

    async fn update_user(&self, user: &User) -> Result<()>;
    async fn delete_user(&self, id: Uuid) -> Result<()>;
    async fn list_users(&self) -> Result<Vec<User>>;
}

pub trait UserRoleRepository {
    fn create_role(&self, role: &UserRole) -> Result<()>;
    fn get_role_by_id(&self, id: Uuid) -> Result<Option<UserRole>>;
    fn list_roles(&self) -> Result<Vec<UserRole>>;
}

pub trait IdentificationTypeRepository {
    fn create_identification_type(&self, id_type: &IdType) -> Result<()>;
    fn get_identification_type_by_id(&self, id: Uuid) -> Result<Option<IdType>>;
    fn list_identification_types(&self) -> Result<Vec<IdType>>;
}

pub trait UserCategoryRepository {
    fn assign_category_to_user(&self, user_category: &UserCategory) -> Result<()>;
    fn get_user_categories(&self, user_id: Uuid) -> Result<Vec<UserCategory>>;
}
--- use_cases/src/user_service/unique_identifier.rs ---
use std::sync::Arc;

use super::err::Error;
use super::{err::Result, repository_trait::UserRepository};
use async_trait::async_trait;
use uuid::Uuid;

#[async_trait]
pub trait Identifier: Sync + Send {
    async fn identify(&self, identifier: &str) -> Result<Uuid>;

    async fn next(&mut self, next: Arc<dyn Identifier>);
}

pub struct EmailIdentifier {
    repo: Arc<dyn UserRepository>,
    next: Option<Arc<dyn Identifier>>,
}

impl EmailIdentifier {
    pub fn new(repo: Arc<dyn UserRepository>, next: Option<Arc<dyn Identifier>>) -> Self {
        Self { repo, next }
    }
}

#[async_trait]
impl Identifier for EmailIdentifier {
    async fn identify(&self, identifier: &str) -> Result<Uuid> {
        if let Some(user_id) = self.repo.get_user_id_by_email(identifier).await? {
            Ok(user_id)
        } else {
            if let Some(next) = self.next.clone() {
                return next.identify(identifier).await;
            }

            Err(Error::InvalidIdentifier)
        }
    }

    async fn next(&mut self, next: Arc<dyn Identifier>) {
        self.next = Some(next);
    }
}

pub struct PhoneIdentifier {
    repo: Arc<dyn UserRepository>,
    next: Option<Arc<dyn Identifier>>,
}

impl PhoneIdentifier {
    pub fn new(repo: Arc<dyn UserRepository>, next: Option<Arc<dyn Identifier>>) -> Self {
        Self { repo, next }
    }
}

#[async_trait]
impl Identifier for PhoneIdentifier {
    async fn identify(&self, identifier: &str) -> Result<Uuid> {
        if let Some(user_id) = self.repo.get_user_id_by_phone(identifier).await? {
            Ok(user_id)
        } else {
            if let Some(next) = self.next.clone() {
                return next.identify(identifier).await;
            }

            Err(Error::InvalidIdentifier)
        }
    }

    async fn next(&mut self, next: Arc<dyn Identifier>) {
        self.next = Some(next);
    }
}
